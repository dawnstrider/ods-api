//    *********************************************
//    *     ASAM ODS 5.3.0 Interface Definition     *
//    *********************************************
//
//    Generated: Tue Nov 20 09:28:37 CET 2012
//
// More explanation for the method getInstancesEx of the interface
// ApplElemAccess.   More details for the method setRelationType of the
// interface ApplicationRelation.
//
// Method getRelationByBaseName of the interface ApplicationElement added.  
// Method getInverseRelationName of instance BaseRelation added.   Better
// explanation in the comments.  Removed unused error codes of the exceptions.
//
// 2003-12-31
// ODS Version 5.0
//
// Add SelOpcode IS_NULL and IS_NOT_NULL.  Add exception AO_INVALID_DATATYPE
// to the method setEnumerationDefinition of the interface ApplicationElement.
//  Method getEnumerationDefinition added to the Interface BaseRelation.  Add
// comment to methods getFormula and setFormula of interface Column.
//
// Add the variable CREATE_COSESSION_ALLOWED at the method newSession at the
// interface AoFactory.   Add the methods createCoSession and getUser at the
// interface AoSession.  Add values of localcolumn at the methods
// getInstances, getInstancesExt and updateInstances of the interface
// ApplElemAccess.  Comment of method setValue of the interface ValueMatrix
// reworked.
//
// Correct the Method getRelationByBaseName of the interface
// ApplicationElement to the Method getRelationsByBaseName, mistake in
// Interface definition there are at some elements relations derived from the
// same base relation allowed.
//
// Add, SUM to the AggrFunc.  Change comment of method getApplicationStructure
// and getBaseStructure of the interface AoSession, the method
// getApplicationStructure of the interface ApplicationElement.and the method
// getRelation of the interface BaseStructure.  Add version string description
// at method getInterfaceVersion of interface AoFactory.
//
// Add the Enumeration ValueMatrixMode.  Change the comment of the Methods
// 13001, 13004, 13006, 14018, 14022, 16003, 21002, 24007  Add the exception
// AO_INVALID_VALUEMATRIX_STRUCTURE for the method getValueMatrix of the
// interface Measurement and ApplElemAccess.  Add the new method
// getValueMatrixInMode of the interfaces Measurement (16005), SubMatrix
// (21004) and ApplElemAccess   Add the methods getSequenceRepresentation
// (13013), setSequenceRepresentation (13014), getGenerationParameters
// (13015), setGenerationParameters (13016) and getRawDataType (13017) of the
// interface Column.  Add the method getMode (22022) of the interface
// ValueMatrix.  Little changes in description of the methods, specify which
// object is modified, with the numbers 4008, 4009, 4010, 4011, 4012, 4013,
// 4014, 4019, 5001, 5002, 5020, 5021, 5022, 5023, 6010, 6011, 6012, 6013,
// 6014, 6015, 6016, 6018, 7002, 7003, 7014, 7015, 12001, 12006, 12007, 13005,
// 14001, 14002, 14014, 14016, 14017, 22014, 22019.  Correct typing errors in
// method 24005
//
// Correct the enumeration ValueMatrixMode. Correct typing errors at method
// 13014. Extend explanation at 13015 and 13016
//
// Typing corrections in IDL:  Method 24005 comment changed. Change the word
// 'calibrated' into     'recalculated' in method 4014 setUnit.
//
// Set the methods hasValueFlag and withValueFlag of the interface
// ApplicationAttribute to deprecated. Change description of createAttribute
// of interface ApplicationElement and ErrorCode AO_MISSING_VALUE.
//
// Add the interfaces ODSDirectory, ODSFile and ODSFileTransfer and
// Enumeration FileOpenMode for the managed files. Add the methods
// getODSDirectory in the interfaces ApplElemAccess and InstanceElement.
//
// Add the methods getEnumerationAttributes and getEnumerationStructure of the
// interface AoSession with the required structures and sequences.
//
// Correct typing error's.
//
// Add AggrFunc DISTINCT, SelOpcode NOTLIKE and CI_NOTLIKE
//
// Remove ODSDirectory, change the way ODSFile is created. Change
// FileOpenMode.
//
// Change the description of the method getUnit of the interface Column. 
// Change the description of the methods of the interfaces ODSFile and
// ODSFileTransfer.  Change the description of the enumerations
// ValueMatrix_Mode and FileOpenMode.  Change the description of the structure
// ApplRel.
//
// Remove Interface ODSFile and ODSFileTransfer and Enumeration FileOpneMode
// with the methods which creates the ODSFile interface.
//
// 2009-09-25
// Correct of some interfacaes and methods the description.   Finalize for
// ASAM ODS version 5.2
//
// Add FOR_USER at auth parameter of method newSession of interface AoFactory 
// Deprecated, solved by NVH Application model for following methods:
// listScalingColumns, getScalingColumns, listColumnsScaledBy,
// getColumnsScaledBy and addColumnScaledBy of interface ValueMatrix and the
// methods isScaling and setScaling of interface Column
//
// Add AoSession.getId()  Add AoFactory.newSessionNameValue()  Add
// SelOpcode.BETWEEN  Add AggrFunc.ORD  Add comment to
// ApplElemAccess.getInstancesExt()
//
// Add method getODSFile at the interfaces ApplElemAccess and InstanceElement.
//  Add the Interfaces ODSFile, ODSReadTransfer and ODSWriteTransfer.  Add
// ErrorCode AO_FILE_LOCKED.  Add AoFile to the description of
// AO_INVALID_BASETYPE
//
// Inherit ODSFile from InstanceElement. Rename method getOdsFile to
// upcastOdsFile at interface InstanceElement. Add methods takeUnderControl
// and removefromControl to the interface ODSFile. Method skipOctets returns
// the real skipped number of octets.  Rename AggrFunc.ORD to AggrFunc.POINT
//
// Update description of the ODSFile methods and some error codes.
//
// Add the method getRelations at the interface BaseStructure.  Minor changes
// in the description of some methods.  Add description for the exceptions
// A_BAD_PARAMETER and AO_SYSTEM_PROBLEM at the method getOctetSeq of the
// interface ODSReadTransfer.
//
// 2012-11-20
// Final release ODS 5.3.0
//
//
#ifndef ods_idl
#define ods_idl

module org {

/**
* ASAM services.
*/
module asam {

/**
* ASAM ODS service.
*/
module ods {
interface AoFactory;
interface AoSession;
interface ApplicationAttribute;
interface ApplicationElement;
interface ApplicationRelation;
interface ApplicationStructure;
interface BaseAttribute;
interface BaseElement;
interface BaseRelation;
interface BaseStructure;
interface Blob;
interface Column;
interface InstanceElement;
interface InstanceElementIterator;
interface Measurement;
interface NameIterator;
interface NameValueIterator;
interface NameValueUnitIterator;
interface SMatLink;
interface SubMatrix;
interface ValueMatrix;
interface NameValueUnitIdIterator;
interface ApplElemAccess;
interface QueryEvaluator;
interface Query;
interface NameValueUnitSequenceIterator;
interface EnumerationDefinition;
interface ElemResultSetExtSeqIterator;
interface ODSFile;
interface ODSReadTransfer;
interface ODSWriteTransfer;

/**
* The ASAM ODS error severity flags.
*/
enum SeverityFlag {
   SUCCESS,     // Ok.
   INFORMATION, // Information.
   WARNING,     // Warning.
   ERROR        // Error.
};

/**
* The ASAM ODS relation types.
*/
enum RelationType {
   FATHER_CHILD, // Father-child relation.
   INFO,         // Info relation.
   INHERITANCE   // Inheritance relation.
};

/**
* The ASAM ODS relationships.
*/
enum Relationship {
   FATHER,    // Father.
   CHILD,     // Child.
   INFO_TO,   // Directed informational relationship.
   INFO_FROM, // Directed informational relationship.
   INFO_REL,  // Informational relationship (no direction)
   SUPERTYPE, // Inheritance relationship: supertype.
   SUBTYPE,   // Inheritance relationship: subtype.
   ALL_REL    // Any of the relationships above.
};

/**
* The ASAM ODS data types.
*    DT_xxx  Basic data types.
*    DS_xxx  Sequence of basic data type.
*    ||
*    |+- T == Type, S == Sequences.
*    +-- D == Datatype.
*/
enum DataType {
   DT_UNKNOWN,           // Unknown datatype.
   DT_STRING,            // String.
   DT_SHORT,             // Short value (16 bit).
   DT_FLOAT,             // Float value (32 bit).
   DT_BOOLEAN,           // Boolean value.
   DT_BYTE,              // Byte value (8 bit).
   DT_LONG,              // Long value (32 bit).
   DT_DOUBLE,            // Double precision float value (64 bit).
   DT_LONGLONG,          // LongLong value (64 bit).
   DT_ID,                // LongLong value (64 bit). Not used. DT_LONGLONG is
                         // used instead.
   DT_DATE,              // Date. Meaning: YYYYMMDDhhmmsslllcccnnn....   -
                         // YYYY = year, required.   - MM = month, optional.  
                         // - DD =  day, optional.   - hh =  hour, optional.  
                         // - mm =  minute, optional.   - ss =  second,
                         // optional.   - lll =  millisec, optional, not
                         // supported by Oracle timestamp.   - ccc =  microse,
                         // optional, not supported by Oracle timestamp.   -
                         // nnn =  nanosec, optional, not supported by Oracle
                         // timestamp.
   DT_BYTESTR,           // Bytestream.
   DT_BLOB,              // Blob.
   DT_COMPLEX,           // Complex value (32 bit each part).
   DT_DCOMPLEX,          // Complex value (64 bit each part).
   DS_STRING,            // String sequence.
   DS_SHORT,             // Short sequence.
   DS_FLOAT,             // Float sequence.
   DS_BOOLEAN,           // Boolean sequene.
   DS_BYTE,              // Byte sequence.
   DS_LONG,              // Long sequence.
   DS_DOUBLE,            // Double sequence.
   DS_LONGLONG,          // Longlong sequence.
   DS_COMPLEX,           // Complex sequence.
   DS_DCOMPLEX,          // Double complex sequence.
   DS_ID,                // LongLong sequence. Not used. DS_LONGLONG is used
                         // instead.
   DS_DATE,              // Date sequence.
   DS_BYTESTR,           // Bytestream sequence.
   DT_EXTERNALREFERENCE, // External reference.
   DS_EXTERNALREFERENCE, // Sequence of external reference.
   DT_ENUM,              // The enumeration datatype.
   DS_ENUM               // The enumeration sequence datatype.
};

/**
* The ASAM ODS build-up function codes for measurement views.
*/
enum BuildUpFunction {
   BUP_JOIN,  // Join the columns
   BUP_MERGE, // Merge the columns
   BUP_SORT   // Sort the columns
};

/**
* The ASAM ODS attribute type codes.
*/
enum AttrType {
   APPLATTR_ONLY, // Report only application attributes.
   INSTATTR_ONLY, // Report only instance attributes.
   ALL            // All attributes.
};

/**
* The ASAM ODS types for setting values.
*/
enum SetType {
   APPEND, // Append data to the value matrix.
   INSERT, // Insert data into the value matrix.
   UPDATE, // Modify existing data of the value matrix.
   REMOVE  // Remove the given information.
};

/**
* The ASAM ODS error codes.
*/
enum ErrorCode {
   AO_UNKNOWN_ERROR,
   AO_ACCESS_DENIED,
   AO_BAD_OPERATION,
   AO_BAD_PARAMETER,
   AO_CONNECT_FAILED,
   AO_CONNECT_REFUSED,
   AO_CONNECTION_LOST,
   AO_DUPLICATE_BASE_ATTRIBUTE,
   AO_DUPLICATE_NAME,
   AO_DUPLICATE_VALUE,
   AO_HAS_INSTANCES,
   AO_HAS_REFERENCES,
   AO_IMPLEMENTATION_PROBLEM,
   AO_INCOMPATIBLE_UNITS,
   AO_INVALID_ASAM_PATH,
   AO_INVALID_ATTRIBUTE_TYPE,
   AO_INVALID_BASE_ELEMENT,
   AO_INVALID_BASETYPE,
   AO_INVALID_BUILDUP_FUNCTION,
   AO_INVALID_COLUMN,
   AO_INVALID_COUNT,
   AO_INVALID_DATATYPE,
   AO_INVALID_ELEMENT,
   AO_INVALID_LENGTH,
   AO_INVALID_ORDINALNUMBER,
   AO_INVALID_RELATION,
   AO_INVALID_RELATION_RANGE,
   AO_INVALID_RELATION_TYPE,
   AO_INVALID_RELATIONSHIP,
   AO_INVALID_SET_TYPE,
   AO_INVALID_SMATLINK,
   AO_INVALID_SUBMATRIX,
   AO_IS_BASE_ATTRIBUTE,
   AO_IS_BASE_RELATION,
   AO_IS_MEASUREMENT_MATRIX,
   AO_MATH_ERROR,
   AO_MISSING_APPLICATION_ELEMENT,
   AO_MISSING_ATTRIBUTE,
   AO_MISSING_RELATION,
   AO_MISSING_VALUE,
   AO_NO_MEMORY,
   AO_NO_PATH_TO_ELEMENT,
   AO_NOT_FOUND,
   AO_NOT_IMPLEMENTED,
   AO_NOT_UNIQUE,
   AO_OPEN_MODE_NOT_SUPPORTED,
   AO_SESSION_LIMIT_REACHED,
   AO_SESSION_NOT_ACTIVE,
   AO_TRANSACTION_ALREADY_ACTIVE,
   AO_TRANSACTION_NOT_ACTIVE,
   AO_HAS_BASE_RELATION,
   AO_HAS_BASE_ATTRIBUTE,
   AO_UNKNOWN_UNIT,
   AO_NO_SCALING_COLUMN,
   AO_QUERY_TYPE_INVALID,
   AO_QUERY_INVALID,
   AO_QUERY_PROCESSING_ERROR,
   AO_QUERY_TIMEOUT_EXCEEDED,
   AO_QUERY_INCOMPLETE,
   AO_QUERY_INVALID_RESULTTYPE,
   AO_INVALID_VALUEMATRIX_STRUCTURE,
   AO_FILE_LOCKED,
   AO_SYSTEM_PROBLEM
};

/**
* The selection operators.  SelOpcode gives query instructions like
* "equal", "greater" etc. So far, these arguments were case sensitive.
* There was a demand to add these arguments also for case insensitive
* comparison operations. Therefore, the SelOpcodes for case insensitivity
* were added. These arguments have the prefix “CI_”.
*/
enum SelOpcode {
   EQ,          // Equal
   NEQ,         // Not equal
   LT,          // Less then
   GT,          // Greater then
   LTE,         // Less then equal
   GTE,         // Greater then equal
   INSET,       // In set, value can be a sequence.
   NOTINSET,    // Not in set, value can be a sequence.
   LIKE,        // like, use  pattern matching, see Pattern for the wildcard
                // definitions.
   CI_EQ,       // Equal. case insensitive for DT_STRING.
   CI_NEQ,      // Not equal. case insensitive for DT_STRING.
   CI_LT,       // Less then. case insensitive for DT_STRING.
   CI_GT,       // Greater then. case insensitive for DT_STRING.
   CI_LTE,      // Less then equal. case insensitive for DT_STRING.
   CI_GTE,      // Greater then equal. case insensitive for DT_STRING.
   CI_INSET,    // In set, value can be a sequence. case insensitive for
                // DT_STRING.
   CI_NOTINSET, // Not in set, value can be a sequence. case insensitive for
                // DT_STRING.
   CI_LIKE,     // like, use  pattern matching, see Pattern for the wildcard
                // definitions. case insensitive for DT_STRING.
   IS_NULL,     // Value is NULL
   IS_NOT_NULL, // Value is not NULL
   NOTLIKE,     // Not LIKE
   CI_NOTLIKE,  // Not LIKE, case insensitive for DT_STRING.
   BETWEEN      // Between; selects all instances where the value of 'attr'
                // lies between the first two values given in 'value' (with
                // 'attr', 'value' being elements of the SelValue structure;
                // 'value' must be of data type S_*).
};

/**
* Operator, bracket open and close.
*/
enum SelOperator {
   AND,   // AND the two conditions.
   OR,    // OR the two conditions.
   NOT,   // Negate the next condition.
   OPEN,  // Open brackets.
   CLOSE  // Close brackets
};

/**
* The ASAM ODS types for setting access rights.
*/
enum RightsSet {
   SET_RIGHT,    // Set the given rights, overwrite the existing rights.
   ADD_RIGHT,    // Add the given rights to the existing rights.
   REMOVE_RIGHT  // Remove the given rights form the existing rights.
};

/**
* Status of the query execution.
*/
enum QueryStatus {
   COMPLETE,   // The execution is ready.
   INCOMPLETE  // The execution is still running.
};

/**
* The supported aggregate functions of the GetInstancesExt.
*/
enum AggrFunc {
   NONE,     // No aggregate function is used for attribute.
   COUNT,    // Count
   DCOUNT,   // Distinct count
   MIN,      // Min; only for numerical values
   MAX,      // Max; only for numerical values
   AVG,      // Average; only for numerical values
   STDDEV,   // Standard deviation; only for numerical values
   SUM,      // Sum; only for numerical values
   DISTINCT, // Distinct
   POINT     // The index of the values, only used by the attribute values of
             // element AoLocalColumn
};

/**
* The selection type.
*/
enum SelType {
   SEL_VALUE_TYPE,    // Selection value.
   SEL_OPERATOR_TYPE  // Selection logical operator.
};

/**
* The type of the join.
*/
enum JoinType {
   JTDEFAULT, // Force inner join.
   JTOUTER    // Force outer join on destination AID.
};

/**
* The mode of the value matrix.
*/
enum ValueMatrixMode {
   CALCULATED, // The value matrix returns the calculated values.   The values
               // of explicit columns are returned as they are stored in the
               // physical storage.   The values of implicit columns are
               // expanded and returned explicitly.  The values of raw columns
               // are calculated according to the corresponding algorithm
               // (using the calculation algorithms given by the values of the
               // application attributes derived from the base attributes
               // 'sequence_representation' and 'generation_parameters') and
               // the resulting physical values are returned.  Writing to the
               // value matrix is not allowed in this mode.
   STORAGE     // The value matrix returns the values given in the physical
               // storage.  The values of explicit columns are returned as
               // they are stored in the physical storage.  The values of
               // implicit columns are expanded and returned explicitly.  The
               // values of raw columns are returned as they are stored
               // (without using the calculation algorithms given by the
               // values of the application attributes derived from the base
               // attributes 'sequence_representation' and
               // 'generation_parameters').  Writing to value matrix is
               // allowed in this mode.
};

// Datatype definitions (T_xxx).
typedef string     T_STRING;
typedef boolean    T_BOOLEAN;
typedef short      T_SHORT;
typedef float      T_FLOAT;
typedef octet      T_BYTE;
typedef long       T_LONG;
typedef double     T_DOUBLE;
typedef T_STRING   Name;
typedef T_STRING   Pattern;
typedef T_STRING   BaseType;
typedef T_STRING   T_DATE;
typedef Blob       T_BLOB;

// Sequence definitions (S_xxx).
typedef sequence<T_BYTE> T_BYTESTR;
typedef sequence<T_BOOLEAN> S_BOOLEAN;
typedef sequence<T_BYTE> S_BYTE;
typedef sequence<T_DOUBLE> S_DOUBLE;
typedef sequence<T_FLOAT> S_FLOAT;
typedef sequence<T_LONG> S_LONG;
typedef sequence<T_SHORT> S_SHORT;
typedef sequence<T_STRING> S_STRING;
typedef sequence<BaseType> BaseTypeSequence;
typedef sequence<Name> NameSequence;
typedef sequence<Column> ColumnSequence;
typedef sequence<SMatLink> SMatLinkSequence;
typedef sequence<SubMatrix> SubMatrixSequence;
typedef sequence<T_DATE> S_DATE;
typedef sequence<T_BYTESTR> S_BYTESTR;
typedef sequence<S_STRING> SS_STRING;
typedef sequence<S_SHORT> SS_SHORT;
typedef sequence<S_FLOAT> SS_FLOAT;
typedef sequence<S_BOOLEAN> SS_BOOLEAN;
typedef sequence<S_BYTE> SS_BYTE;
typedef sequence<S_LONG> SS_LONG;
typedef sequence<S_DOUBLE> SS_DOUBLE;
typedef sequence<S_DATE> SS_DATE;
typedef sequence<S_BYTESTR> SS_BYTESTR;
typedef sequence<T_BLOB> S_BLOB;
typedef sequence<ApplicationElement> ApplicationElementSequence;
typedef sequence<ApplicationRelation> ApplicationRelationSequence;
typedef sequence<ApplicationAttribute> ApplicationAttributeSequence;
typedef sequence<BaseRelation> BaseRelationSequence;
typedef sequence<BaseAttribute> BaseAttributeSequence;
typedef sequence<BaseElement> BaseElementSequence;
typedef sequence<InstanceElement> InstanceElementSequence;
typedef sequence<SelOperator> SelOperatorSequence;

/**
* The ASAM ODS relation range structure.
*/
struct RelationRange {
   T_SHORT min; // The minimum number in the range.
   T_SHORT max; // The maximum number in the range. -1 means MANY without a
                // specified maximum number.
};

/**
* The ASAM ODS 64 bit integer structure.  This type is represented in the
* datatype enumeration by DT_LONGLONG.
*/
struct T_LONGLONG {
   T_LONG high; // The most significant 32 bits of the 64 bit value.
   T_LONG low;  // The least significant 32 bits of the 64 bit value.
};

/**
* The ASAM ODS complex data structure.  This type is represented in the
* datatype enumeration by DT_COMPLEX.
*/
struct T_COMPLEX {
   T_FLOAT r; // The real part of the complex number.
   T_FLOAT i; // The imaginary part of the complex number.
};

/**
* The ASAM ODS double-precision complex data structure. This type is
* represented in the datatype enumeration by DT_DCOMPLEX.
*/
struct T_DCOMPLEX {
   T_DOUBLE r; // The real part of the double precision complex number.
   T_DOUBLE i; // The imaginary part of the double precision complex number.
};

/**
* The ASAM ODS name-unit tuple structure.
*/
struct NameUnit {
   Name     valName; // Attribute name or measured quantity name.
   T_STRING unit;    // Column unit as string.
};

/**
* The description of an reference object, the reference object can be an
* internal ASAM ODS object or an external object. This type is
* represented in the datatype enumeration by DT_EXTERNALREFERENCE.
*/
struct T_ExternalReference {
   T_STRING description; // Description of the external reference.
   T_STRING mimeType;    // MIME-type of the external object.
   T_STRING location;    // Location of the external reference. (asam path or
                         // URL)
};

/**
* The application attribute information (metadata) definition. The same
* information is available at the interface ApplicationAttribute
*/
struct ApplAttr {
   Name       aaName;       // The application attribute name. The same name
                            // is returned by the method getName() of the
                            // ApplicationAttribute interface.     At the RPC
                            // API this information was stored in the field
                            // aAName of the structure AttrSeq and the request
                            // AOP_GetAttr.
   Name       baName;       // The name of the base attribute, empty ("") if
                            // the application attribute is not derived from a
                            // base attribute. The same name is returned by
                            // the methods getName() of the BaseAttribute
                            // interface. The base attribute is given by the
                            // the method getBaseAttribute() of the interface
                            // ApplicationAttribute.     At the RPC API this
                            // information was stored in the field aBName of
                            // the structure AttrSeq and the request
                            // AOP_GetAttr.
   DataType   dType;        // The attribute data type. The same data type is
                            // given by the method getDataType of the
                            // interface ApplicationAttribute.     At the RPC
                            // API this information was stored in the field
                            // aDataType of the structure AttrSeq and the
                            // request AOP_GetAttr.
   T_LONG     length;       // The maximum possible length of values. The same
                            // length is returned by the method getLength() of
                            // the interface ApplicationAttribute.
   T_BOOLEAN  isObligatory; // The indicator for mandatory attributes, the
                            // notNull indicator is set at the column of the
                            // table in the physical storage.  The same
                            // boolean is returned at the method
                            // isObligatory() of the interface
                            // ApplicationAttribute.
   T_BOOLEAN  isUnique;     // The indicator for unique attributes. The same
                            // boolean is returned by the method isUnique() of
                            // the interface ApplicationAttribute.
   T_LONGLONG unitId;       // Id of the unit if global defined. The same Id
                            // is returned by the method getUnit() of the
                            // interface ApplicationAttribute.     At the RPC
                            // API this information was stored in the field
                            // aUnit of the structure AttrSeq and the request
                            // AOP_GetAttr.
};

/**
* The application relation info structure. The same information is
* available at the interface ApplicationRelation. 
* 
* A relation is the connection between two ASAM ODS elements; it may be
* navigated in both
* directions. The get- and set- methods are defined from the first
* element, the getInverse- and
* setInverse- methods work from the second element.
*/
struct ApplRel {
   T_LONGLONG    elem1;            // The source application element Id. The
                                   // given Id is the Id of the application
                                   // element returned from the method
                                   // getElem1() of the interface
                                   // ApplicationRelation.     At the RPC API
                                   // this information was stored in the field
                                   // arAid1 of the structure ApplRelSeq and
                                   // the request AOP_GetApplInf.
   T_LONGLONG    elem2;            // The target application element Id. The
                                   // given Id is the Id of the application
                                   // element returned from the method
                                   // getElem2() of the interface
                                   // ApplicationRelation.     At the RPC API
                                   // this information was stored in the field
                                   // arAid2 of the structure ApplRelSeq and
                                   // the request AOP_GetApplInf.
   Name          arName;           // The relation name. The name is return
                                   // with the method getName() of the
                                   // interface ApplicationRelation.     At
                                   // the RPC API this information was stored
                                   // in the field arName of the structure
                                   // ApplRelSeq and the request
                                   // AOP_GetApplInf.
   Name          invName;          // Name of the inverse relation. The name
                                   // is return with the method
                                   // getInverseName() of the interface
                                   // ApplicationRelation. The invName is not
                                   // available in the physical storage for
                                   // relation databases.
   Name          brName;           // Name of the base relation from the elem1
                                   // to the elem2. The base relation is also
                                   // not stored in the physical storage.
   Name          invBrName;        // Name of the inverse base relation from
                                   // the elem2 to the elem1. The base
                                   // relation is also not stored in the
                                   // physical storage.
   RelationType  arRelationType;   // The type of the relation. Type of the
                                   // relation is not stored in the physical
                                   // storage. The relation type is return at
                                   // the method getRelationType() of the
                                   // interface ApplicationRelation.
   RelationRange arRelationRange;  // The range of the relation. Range of the
                                   // relation is not stored in the physical
                                   // storage. The relation range is return at
                                   // the method getRelationRange() of the
                                   // interface ApplicationRelation.
   RelationRange invRelationRange; // The inverse range of the relation. Range
                                   // of the relation is not stored in the
                                   // physical storage. The inverse relation
                                   // range is return at the method
                                   // getInverseRelationRange() of the
                                   // interface ApplicationRelation.
};

/**
* AID - Name pair.
*/
struct AIDName {
   T_LONGLONG aid;    // The Id of the application element.
   Name       aaName; // The attribute, or measured quantity name.
};

/**
* Instance element Id. The unique description of an instance element.
*/
struct ElemId {
   T_LONGLONG aid; // The Id of the application element.
   T_LONGLONG iid; // The Id of the instance element.
};

/**
* AID - Name - UnitId tuple.
*/
struct AIDNameUnitId {
   AIDName    attr;   // The attribute  of the application element (aid,
                      // name).
   T_LONGLONG unitId; // The unit of the attribute or the column. The unitId
                      // is the Id of instance element with the basetype
                      // AoUnit.
};

/**
* Order criteria.
*/
struct SelOrder {
   AIDName   attr;      // Attribute specification.
   T_BOOLEAN ascending; // ascending order, FALSE means descending.
};

/**
* The access control list entry.
*/
struct ACL {
   T_LONGLONG usergroupId; // The usergroup Id.
   T_LONG     rights;      // The access rights of the requested object.
};

/**
* An initial right.
*/
struct InitialRight {
   T_LONG     rights;      // The initial access rights of the requested
                           // object.
   T_LONGLONG usergroupId; // The usergroup Id of the Initial right list.
   T_LONGLONG refAid;      // The referencing application element.
};

/**
* it’s quite the same sequence as in the QueryStructure of GetInstances
* with one exception. It has one new attribute called function, which is
* of the type AggrFunc. Thereby  it is possible to define aggregate
* functions on attribute level, without the need to parse the attribute
* name for a known aggregate function name. The default value of that
* attribute function is NONE, it symbolizes that no aggregate function
* should be applied on that attribute.If an aggregate function is used,
* it is also required to define a GroupSequence.It is also defined that a
* ‘*’ as attribute name, delivers all attributes of an element.
*/
struct SelAIDNameUnitId {
   AIDName    attr;      // The attribute  of the application element (aid,
                         // name).
   T_LONGLONG unitId;    // The unit of the attribute ot the column. The
                         // unitId is the Id of instance element with the
                         // basetype AoUnit.
   AggrFunc   aggregate; // The aggregate function.
};

/**
* Basically, joins can only be realized between application elements that
* are linked via a reference defined in the model.From the definition of
* attributes or application elements, the references for the joins are
* determined. It is also taken into account that the application elements
* involved are not linked directly. However, there must be an unambiguous
* path between the application elements. The path may also include n:m
* relations. The unambiguousness of relations between two application
* elements no longer exists if more than one reference has been defined
* between the application elements. In this case, these references must
* have names and must be indicated explicitly in the request.For this
* purpose, the request structure provides a sequence of relation
* definitions (JoinDefSequence). The sequence in which the application
* elements are addressed in the request also determines the sequence in
* which the references between application elements are searched. Thus,
* for every new application element, the server begins with the first
* application element addressed in the request and tries to find a
* relation from there. If no reference to the first application element
* can be found, the search continues with the application element that
* comes next in the request. Furthermore, the explicit relation
* definitions (JoinDefSequence) enable an OUTER join, i.e. the result
* also includes those records for which the join could not be
* established.
*/
struct JoinDef {
   T_LONGLONG fromAID;
   T_LONGLONG toAID;
   Name       refName;
   JoinType   joiningType;
};

/**
* The application relation with the instances to create the relation with
* new instances.
*/
struct ApplicationRelationInstanceElementSeq {
   ApplicationRelation     applRel;   // The application relation.
   InstanceElementSequence instances; // The list with instances. The
                                      // application element of the instances
                                      // in the list must match one of the
                                      // application elements of the
                                      // application relation. All instances
                                      // of the list must have the same
                                      // application element.
};

/**
* The structure with the attribute and the name of the enumeration.
*/
struct EnumerationAttributeStructure {
   T_LONGLONG aid;      // The application element Id.
   T_STRING   aaName;   // The name of the attribute
   T_STRING   enumName; // The name of the enumeration
};

/**
* The structure with the items of the enumeration.
*/
struct EnumerationItemStructure {
   T_LONG   index;    // The index of the enuemration item.
   T_STRING itemName; // The name of the item.
};

// Sequence definitions (S_xxx).
typedef sequence<EnumerationAttributeStructure> EnumerationAttributeStructureSequence;
typedef sequence<EnumerationItemStructure> EnumerationItemStructureSequence;
typedef sequence<T_COMPLEX> S_COMPLEX;
typedef sequence<T_DCOMPLEX> S_DCOMPLEX;
typedef sequence<T_LONGLONG> S_LONGLONG;
typedef sequence<S_LONGLONG> SS_LONGLONG;
typedef sequence<S_COMPLEX> SS_COMPLEX;
typedef sequence<S_DCOMPLEX> SS_DCOMPLEX;
typedef sequence<T_ExternalReference> S_ExternalReference;
typedef sequence<S_ExternalReference> SS_ExternalReference;
typedef sequence<ApplAttr> ApplAttrSequence;
typedef sequence<ApplRel> ApplRelSequence;
typedef sequence<AIDName> AIDNameSequence;
typedef sequence<AIDNameUnitId> AIDNameUnitIdSequence;
typedef sequence<ElemId> ElemIdSequence;
typedef sequence<SelOrder> SelOrderSequence;
typedef sequence<ACL> ACLSequence;
typedef sequence<InitialRight> InitialRightSequence;
typedef sequence<SelAIDNameUnitId> SelAIDNameUnitIdSequence;
typedef sequence<JoinDef> JoinDefSequence;
typedef sequence<ApplicationRelationInstanceElementSeq> ApplicationRelationInstanceElementSeqSequence;

/**
* The application element definition. The same information is available
* at the interface ApplicationElement.
*/
struct ApplElem {
   T_LONGLONG       aid;        // The application element id. The id is given
                                // also with the method getId() at the
                                // interface ApplicationElement.     At the
                                // RPC API this information was stored in the
                                // field aiAId of the structure ApplInfSeq and
                                // the request AOP_GetApplInf.
   Name             beName;     // The base element name, all elements have a
                                // basic element. The same name is returned by
                                // the methods getType() of the BaseElement
                                // interface. The base element is given with
                                // the method getBaseElement() at the
                                // interface ApplicationElement.     At the
                                // RPC API this information was not delivered
                                // but the corresponding Id of the base
                                // element was stored in the field aiBId of
                                // the structure ApplInfSeq and the request
                                // AOP_GetApplInf.
   Name             aeName;     // The application element name. The name is
                                // given also with the method getName() at the
                                // interface ApplicationElement.     At the
                                // RPC API this information was stored in the
                                // field aiName of the structure ApplInfSeq
                                // and the request AOP_GetApplInf.
   ApplAttrSequence attributes; // The attributes of application element. The
                                // attributes are given with the method
                                // getAttributes() of the interface
                                // ApplicationElement. There are no relations
                                // given in the this sequence.
};

/**
* The structure with the enumeration and there items.
*/
struct EnumerationStructure {
   T_STRING                         enumName; // The name of the enueration.
   EnumerationItemStructureSequence items;    // The items of the enumeration.
};

/**
* The union definition for all datatypes.
*/
union TS_Union switch (DataType) {
   case DT_STRING:                      T_STRING                       stringVal;
   case DT_SHORT:                       T_SHORT                        shortVal;
   case DT_FLOAT:                       T_FLOAT                        floatVal;
   case DT_BYTE:                        T_BYTE                         byteVal;
   case DT_BOOLEAN:                     T_BOOLEAN                      booleanVal;
   case DT_LONG:                        T_LONG                         longVal;
   case DT_DOUBLE:                      T_DOUBLE                       doubleVal;
   case DT_LONGLONG:                    T_LONGLONG                     longlongVal;
   case DT_COMPLEX:                     T_COMPLEX                      complexVal;
   case DT_DCOMPLEX:                    T_DCOMPLEX                     dcomplexVal;
   case DT_DATE:                        T_DATE                         dateVal;
   case DT_BYTESTR:                     T_BYTESTR                      bytestrVal;
   case DT_BLOB:                        T_BLOB                         blobVal;
   case DS_STRING:                      S_STRING                       stringSeq;
   case DS_SHORT:                       S_SHORT                        shortSeq;
   case DS_FLOAT:                       S_FLOAT                        floatSeq;
   case DS_BYTE:                        S_BYTE                         byteSeq;
   case DS_BOOLEAN:                     S_BOOLEAN                      booleanSeq;
   case DS_LONG:                        S_LONG                         longSeq;
   case DS_DOUBLE:                      S_DOUBLE                       doubleSeq;
   case DS_LONGLONG:                    S_LONGLONG                     longlongSeq;
   case DS_COMPLEX:                     S_COMPLEX                      complexSeq;
   case DS_DCOMPLEX:                    S_DCOMPLEX                     dcomplexSeq;
   case DS_DATE:                        S_DATE                         dateSeq;
   case DS_BYTESTR:                     S_BYTESTR                      bytestrSeq;
   case DT_EXTERNALREFERENCE:           T_ExternalReference            extRefVal;
   case DS_EXTERNALREFERENCE:           S_ExternalReference            extRefSeq;
   case DT_ENUM:                        T_LONG                         enumVal;
   case DS_ENUM:                        S_LONG                         enumSeq;
};

/**
* Define a union with sequences of a certain type. Using this union
* instead of sequence <TS_Union> gives much better performance.
*/
union TS_UnionSeq switch (DataType) {
   case DT_STRING:                      S_STRING                       stringVal;
   case DT_SHORT:                       S_SHORT                        shortVal;
   case DT_FLOAT:                       S_FLOAT                        floatVal;
   case DT_BYTE:                        S_BYTE                         byteVal;
   case DT_BOOLEAN:                     S_BOOLEAN                      booleanVal;
   case DT_LONG:                        S_LONG                         longVal;
   case DT_DOUBLE:                      S_DOUBLE                       doubleVal;
   case DT_LONGLONG:                    S_LONGLONG                     longlongVal;
   case DT_COMPLEX:                     S_COMPLEX                      complexVal;
   case DT_DCOMPLEX:                    S_DCOMPLEX                     dcomplexVal;
   case DT_DATE:                        S_DATE                         dateVal;
   case DT_BYTESTR:                     S_BYTESTR                      bytestrVal;
   case DT_BLOB:                        S_BLOB                         blobVal;
   case DS_STRING:                      SS_STRING                      stringSeq;
   case DS_SHORT:                       SS_SHORT                       shortSeq;
   case DS_FLOAT:                       SS_FLOAT                       floatSeq;
   case DS_BYTE:                        SS_BYTE                        byteSeq;
   case DS_BOOLEAN:                     SS_BOOLEAN                     booleanSeq;
   case DS_LONG:                        SS_LONG                        longSeq;
   case DS_DOUBLE:                      SS_DOUBLE                      doubleSeq;
   case DS_LONGLONG:                    SS_LONGLONG                    longlongSeq;
   case DS_COMPLEX:                     SS_COMPLEX                     complexSeq;
   case DS_DCOMPLEX:                    SS_DCOMPLEX                    dcomplexSeq;
   case DS_DATE:                        SS_DATE                        dateSeq;
   case DS_BYTESTR:                     SS_BYTESTR                     bytestrSeq;
   case DT_EXTERNALREFERENCE:           S_ExternalReference            extRefVal;
   case DS_EXTERNALREFERENCE:           SS_ExternalReference           extRefSeq;
   case DT_ENUM:                        S_LONG                         enumVal;
   case DS_ENUM:                        SS_LONG                        enumSeq;
};

// Sequence definitions (S_xxx).
typedef sequence<EnumerationStructure> EnumerationStructureSequence;
typedef sequence<ApplElem> ApplElemSequence;

/**
* The ASAM ODS value structure.  There is one flag for each value. If the
* union (u) contains a sequence, the flag is valid for all values in that
* sequence.
* 
* Meaning of flags:
*    AO_VF_VALID(0x01)      The value is valid.
*    AO_VF_VISIBLE(0x02)    The value has to be
*                           visualized.
*    AO_VF_UNMODIFIED(0x04) The value has not been
*                           modified.
*    AO_VF_DEFINED(0x08)    The value is defined. If
*                           the value in a value matrix
*                           is not available this bit
*                           is not set.
*   The normal value of the flag is 15.
*/
struct TS_Value {
   TS_Union u;    // The value union for values of all known datatypes.
   T_SHORT  flag; // The value flags.
};

/**
* A structure with sequences of a certain type. Using this union instead
* of sequence <TS_Value> gives much better performance.
*/
struct TS_ValueSeq {
   TS_UnionSeq u;    // The value union for values of all known datatypes.
   S_SHORT     flag; // See TS_Value flag.
};

/**
* Application structure values. All values of the entire application
* structure are stored in this structure and loaded to the Client on
* request. 
* 
* At the RPC API this information delivered by the request AOP_GetApplInf
* and AOP_GetAttr for each application element.
*/
struct ApplicationStructureValue {
   ApplElemSequence applElems; // The list of application elements.
   ApplRelSequence  applRels;  // The list of relations in the application
                               // structure. The list of ApplRel's contains
                               // distinct entries for relations and their
                               // inverses. The field invName contains the
                               // partner relation.  Both relation, the normal
                               // and the inverse relation are given in the
                               // sequence.
};

/**
* The ASAM ODS name-value-unit tuple structure with a sequence of values.
*/
struct NameValueSeqUnit {
   Name        valName; // Column name or measured quantity name.
   TS_ValueSeq value;   // Column value (vector).
   T_STRING    unit;    // Column unit as string.
};

/**
* AID - Name - Value - UnitId quartet.
*/
struct AIDNameValueUnitId {
   AIDName    attr;   // The attribute  of the application element (aid,
                      // name).
   T_LONGLONG unitId; // The unit of the attribute ot the column. The unitId
                      // is the Id of instance element with the basetype
                      // AoUnit.
   TS_Value   values; // The attribute values with value flags.
};

/**
* AID - Name - Value - UnitId quartet. Multiple values for on attribute.
*/
struct AIDNameValueSeqUnitId {
   AIDName     attr;   // The attribute  of the application element (aid,
                       // name).
   T_LONGLONG  unitId; // The unit of the attribute ot the column. The unitId
                       // is the Id of instance element with the basetype
                       // AoUnit.
   TS_ValueSeq values; // The column values with value flags.
};

/**
* The ASAM ODS name-value-unitId tuple structure with a sequence of
* values.
*/
struct NameValueSeqUnitId {
   Name        valName; // Column name or measured quantity name.
   TS_ValueSeq value;   // Column value (vector).
   T_LONGLONG  unitId;  // Column unit as Id.
};

/**
*  Structure for name value query or attribute search conditions.
*/
struct SelValue {
   AIDNameValueUnitId attr;  // The attribute specification with unit of the
                             // value.
   SelOpcode          oper;  // The compare operator between the attribute and
                             // value.
   TS_Value           value; // Value for the condition.
};

/**
* The ASAM ODS name-value-unitid tuple structure. This structure is
* identical with the NameValueUnit, except the unit is given as an Id
* insead of a string.
*/
struct NameValueUnitId {
   Name       valName; // Attribute name or measured quantity name.
   TS_Value   value;   // Attribute value or column value (vector).
   T_LONGLONG unitId;  // Id of attribute or column unit.
};

/**
* The attribute selection structure.
*/
struct SelValueExt {
   AIDNameUnitId attr;  // The attribute specification with unit Id.
   SelOpcode     oper;  // The compare operator between the attribute and
                        // value.
   TS_Value      value; // Value for the condition.
};

/**
* Defines the sequence of selection attributes with their logical
* operators. The Idea is to have the logical operators and the selection
* values in one sequence. Therefore no implicit rules are necessary how
* logical operators have to be interpreted to the corresponding selection
* value.
*/
union SelItem switch (SelType) {
   case SEL_VALUE_TYPE:                 SelValueExt                    value;
   case SEL_OPERATOR_TYPE:              SelOperator                    operator;
};

// Sequence definitions (S_xxx).
typedef sequence<NameValueSeqUnit> NameValueSeqUnitSequence;
typedef sequence<AIDNameValueSeqUnitId> AIDNameValueSeqUnitIdSequence;
typedef sequence<SelValue> SelValueSequence;
typedef sequence<NameValueSeqUnitId> NameValueSeqUnitIdSequence;
typedef sequence<SelItem> SelItemSequence;

/**
* The ASAM ODS name-value pair structure.
*/
struct NameValue {
   Name     valName; // Attribute name or measured quantity name.
   TS_Value value;   // Attribute value or column value (vector).
};

/**
* The ASAM ODS name-value-unit tuple structure. This structure is
* identical with the NameValueUnitId, except the unit is given as a
* string insead of an Id.
*/
struct NameValueUnit {
   Name     valName; // Attribute name or measured quantity name.
   TS_Value value;   // Attribute value or column value (vector).
   T_STRING unit;    // Attribute or column unit as string.
};

/**
* The results for one attribute. The result set for all attributes are
* given in the sequence of the result set.
*/
struct AttrResultSet {
   NameValueSeqUnitId      attrValues; // The attribute result set of one
                                       // element. All values have the same
                                       // attribute (AIDName) and the same
                                       // unit (UnitId). Only the first part
                                       // of the possible attribute values are
                                       // available in this result set. The
                                       // size of the part depends on the
                                       // parameter 'how_many' of the method
                                       // 'getInstances' of the interface
                                       // 'ApplElemAccess'.
   NameValueUnitIdIterator rest;       // The rest of the results. The
                                       // iterator provides access to the
                                       // conseccutive
                                       // NameValueSeqUnitId-packages of the
                                       // result set.
};

/**
* The query structure.
* 
* How to build a query.
* 
* A query is a search condition for instances. The instances are
* specified by the values of the attributes. The search condition
* represents an attribute value condition. This means the attribute value
* specifies the selection of the instance or instance attribute. An
* attribute is specified by the application element and the name of the
* attribute (AIDName). The conditions are defined in the enumeration
* SelOPCode. The values are given in the TS_Value or TS_Union structure.
* If we like an Unit indepedent condition we needed to define the Unit at
* the attribute, use AIDNameUnitId instead of AIDName, the server has to
* convert the value to the proper attribute value. The attribute search
* condition can be combined by operations defined in the enumeration
* SelOperator. A query can be built with a sequence SelValue and
* SelOperator.
* 
* How to read/write the query:
* 
* e.g.  SelValue1 AND SelValue2
*   
*          selValueSeq    = SelValue1, SelValue2
*          selOPeratorSeq = AND  
* 
* e.g.  (SelValue1 AND SelValue2) OR SelValue3 
*    
*          selValueSeq    = SelValue1, SelValue2, SelValue3
*          selOPeratorSeq = OPEN, AND, CLOSE, OR
*    
* e.g.  NOT(SelValue1 AND SelValue2) OR SelValue3 
*    
*          selValueSeq    = SelValue1, SelValue2, SelValue3
*          selOPeratorSeq = NOT, OPEN, AND, CLOSE, OR
*    
*  e.g.  NOT(SelValue1) AND SelValue2 OR SelValue3 
*    
*          selValueSeq    = SelValue1, SelValue2, SelValue3
*          selOPeratorSeq = NOT, AND, OR
* 
* There is no selection about the N:M relations.
*  
* There are no aggregate functions (MAX, MIN, COUNT etc.) defined so we
* need no "group by" and "having" Clause. All the parts defined in the
* "having"-clause can be defined in the select part.
*/
struct QueryStructure {
   AIDNameUnitIdSequence anuSeq;  // The sequence of attributes to be
                                  // reported. A pattern is accepted for the
                                  // attribute name.    At the RPC API this
                                  // information was stored in the fields
                                  // applId and nuSeq of the structure
                                  // GetValReq and the request AOP_GetVal. At
                                  // the RPC API only one application element
                                  // could be selected.
   SelValueSequence      condSeq; // The query condition sequence.     At the
                                  // RPC API this information was stored in
                                  // the field nsSeq of the structure
                                  // GetValReq and the request AOP_GetVal.
   SelOperatorSequence   operSeq; // The query condition operator sequence.   
                                  //  At the RPC API was the operator always
                                  // 'AND'.
   ElemId                relInst; // The related instance. (aid == 0 && iid ==
                                  // 0) means no related instance specified.  
                                  //         At the RPC API this information
                                  // was stored in the field elemId of the
                                  // structure GetValReq and the request
                                  // AOP_GetVal.
   Name                  relName; // Name of the relation.     At the RPC API
                                  // this information was stored in the field
                                  // refName of the structure GetValReq and
                                  // the request AOP_GetVal.
   SelOrderSequence      orderBy; // The order by sequence. The order of the
                                  // result set.     At the RPC API it was not
                                  // possiable to set the order.
};

/**
* Restult set of one application element.
*/
struct ElemResultSetExt {
   T_LONGLONG                 aid;    // The application element Id.
   NameValueSeqUnitIdSequence values; // The attribute values of the instances
                                      // of the given application element.
};

/**
* The extended query structure.
*/
struct QueryStructureExt {
   SelAIDNameUnitIdSequence anuSeq;  // The sequence of attributes to be
                                     // reported. A pattern is accepted for
                                     // the attribute name.    At the RPC API
                                     // this information was stored in the
                                     // fields applId and nuSeq of the
                                     // structure GetValReq and the request
                                     // AOP_GetVal. At the RPC API only one
                                     // application element could be selected.
   SelItemSequence          condSeq; // The query condition sequence.     At
                                     // the RPC API this information was
                                     // stored in the field nsSeq of the
                                     // structure GetValReq and the request
                                     // AOP_GetVal.
   JoinDefSequence          joinSeq; // Defined the join between the
                                     // application elements.
   SelOrderSequence         orderBy; // The order by sequence. The order of
                                     // the result set.     At the RPC API
                                     // interface it was not possiable to set
                                     // the order.
   AIDNameSequence          groupBy; // Defines the grouping attributes for a
                                     // request, necessary if aggregate
                                     // functions are defined in the
                                     // SelAIDNameUnitIdSequence.
};

// Sequence definitions (S_xxx).
typedef sequence<NameValue> NameValueSequence;
typedef sequence<NameValueUnit> NameValueUnitSequence;
typedef sequence<AttrResultSet> AttrResultSetSequence;
typedef sequence<ElemResultSetExt> ElemResultSetExtSequence;

/**
* The result set for one element. The result set for all elements are
* given in the sequence of the result set.
*/
struct ElemResultSet {
   T_LONGLONG            aid;        // The Id of the application element.
   AttrResultSetSequence attrValues; // The selected attributes of the
                                     // element. The number of values in each
                                     // AttrResultSet are identical, the
                                     // attributes of one element has always
                                     // the position in the AttrResultSet.
};

/**
* The Result set of the extended query. The iterator is for instance
* oriented access.
*/
struct ResultSetExt {
   ElemResultSetExtSequence    firstElems; // The sequence of the first
                                           // how_many result elements.
   ElemResultSetExtSeqIterator restElems;  // the iterator, which allows to
                                           // iterate above the result values,
                                           // the attributes of one instance
                                           // each iteration.
};

// Sequence definitions (S_xxx).
typedef sequence<ElemResultSet> ElemResultSetSequence;
typedef sequence<ResultSetExt> ResultSetExtSequence;

/**
* The ASAM ODS query result types.
*/
interface ResultType {
   const T_SHORT INSTELEM_ITERATOR_AS_RESULT = 0; // Iterator of instance elements as result of the query (the default).
   const T_SHORT TABLE_ITERATOR_AS_RESULT = 1;    // Iterator for table access as result type of the query.
   const T_SHORT TABLE_AS_RESULT = 2;             // Table as result type of the query.
};

/**
* The lock mode of the server. The lock mode tells the way the server
* will lock the objects as soon a modification of the server will be
* done.
*/
interface LockMode {
   const T_SHORT LOCK_INSTANCEELEMENT = 0;    // Lock the instance element. (Default LockMode)
   const T_SHORT LOCK_APPLICATIONELEMENT = 1; // Lock the application element, all instances of the application element are locked.
   const T_SHORT LOCK_CHILDREN = 2;           // Lock the children of the locked object. This mode can be combined with one of the upper two modi.
};

/**
* The bits of the security rights.
*/
interface SecurityRights {
   const T_LONG SEC_READ = 1;   // Read access is allowed.
   const T_LONG SEC_UPDATE = 2; // Update access to an existing object is allowed.
   const T_LONG SEC_INSERT = 4; // Creating new instances is allowed.
   const T_LONG SEC_DELETE = 8; // Delete of the object is allowed.
   const T_LONG SEC_GRANT = 16;  // Access rights may be passed on.
};

/**
* The security level of an application element.
*/
interface SecurityLevel {
   const T_LONG NO_SECURITY = 0;        // No security defined.
   const T_LONG ELEMENT_SECURITY = 1;   // Security scaled for the application element.
   const T_LONG INSTANCE_SECURITY = 2;  // Security scaled for instance elements.
   const T_LONG ATTRIBUTE_SECURITY = 4; // Security scaled for appliation attributes.
};

/**
* The ASAM ODS query constants.
*/
interface QueryConstants {
   const T_LONG MaxDurationDEFAULT = 0;     // Default value of max duration parameter of the query  (no limitations).
   const T_STRING MaxDuration = "MaxDuration";            // The ASAM ODS max duration parameter of the query.
   const T_STRING QueryResultType = "QueryResultType";        // The ASAM ODS query result type parameter.
   const T_LONG QueryResultTypeDEFAULT = ResultType::INSTELEM_ITERATOR_AS_RESULT; // Default value of the ASAM ODS query result type parameter.
};

/**
* The ASAM ODS exception structure.
*/
exception AoException {
   ErrorCode    errCode;
   SeverityFlag sevFlag;
   T_LONG       minorCode;
   T_STRING     reason;
};

/**
* The ASAM factory interface.
*/
interface AoFactory {

   /** (2001)
   * Get the description of the ASAM ODS factory. If the description is
   * not available an empty string is returned and no exception is
   * thrown. The server loads the description from the base attribute
   * "description" of the instance of AoEnvironment.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The description of the ASAM ODS factory.
   */
   T_STRING getDescription()
      raises (AoException);

   /** (2002)
   * Get the interface version of the ASAM ODS factory. The interface
   * version is for each ODS version a fixed string. The string is the
   * version of the interface implemented at the server. 
   * 
   * The format of the string is:
   * V<Major Version Nr>.<Minor Version Nr>.<Revision Nr>
   *   - Major Version Nr (numeric: [0-9]+)
   *   - Minor Version Nr (numeric: [0-9]+)
   *   - Revision Nr (numeric: [0-9]+)
   * Example of the version specification is 'V5.1.0'.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The interface version of the ASAM ODS factory.
   */
   T_STRING getInterfaceVersion()
      raises (AoException);

   /** (2003)
   * Get the name of the ASAM ODS factory. If the name is not available
   * an empty string is returned and no exception is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The name of the ASAM ODS factory.
   */
   T_STRING getName()
      raises (AoException);

   /** (2004)
   * Get the type of the ASAM ODS factory. If the type is not available
   * an empty string is returned and no exception is thrown. The server
   * loads the type from the base attribute "Application_model_type" of
   * the instance of AoEnvironment.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The type of the ASAM ODS factory.
   */
   T_STRING getType()
      raises (AoException);

   /** (2005)
   * Establish a new session to an ASAM ODS server. The server normally
   * checks the activity of the session and will close the session after
   * a time period of inactivity.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECT_FAILED
   *    AO_CONNECT_REFUSED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_OPEN_MODE_NOT_SUPPORTED
   *    AO_SESSION_LIMIT_REACHED
   *
   * @param  auth  A string that may contain authentication information.
   *               The following values are currently supported:
   *                  USER
   *                  PASSWORD
   *                  CREATE_COSESSION_ALLOWED
   *                  FOR_USER
   *                The values may be specified in any order and have to
   *               be separated by comma.
   *               The variable CREATE_COSESSION_ALLOWED
   *                       Value (DT_STRING) TRUE or FALSE
   *                       Default for CREATE_COSESSION_ALLOWED =
   *               FALSE.
   *                      The variable CREATE_COSESSION_ALLOWED is a
   *               read-only variable in the session.
   *               The variable FOR_USER is the name of the user for
   *               which this session shall be created. If this value is
   *               given, USER must be a superuser. Otherwise the
   *               exception AO_CONNECT_REFUSED will be thrown.
   *               Example:
   *               "USER=hans, PASSWORD=secret, CREATE_COSESSION_ALLOWED
   *               = TRUE"
   *
   * @return  The new created ASAM ODS session.
   */
   AoSession newSession(
      in T_STRING auth)
      raises (AoException);

   /** (2006)
   * Establish a new session to an ASAM ODS server. The server normally
   * checks the activity of the session and will close the session after
   * a time period of inactivity. The authentication is a list of
   * NameValue which is an argument of the method.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECT_FAILED
   *    AO_CONNECT_REFUSED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_OPEN_MODE_NOT_SUPPORTED
   *    AO_SESSION_LIMIT_REACHED
   *
   * @param  auth  A list of NameValue with the parameters for the
   *               authentication, the parameter is stored in the Name of
   *               the NameValue and the value of the aprameter is stored
   *               in the Value. Each entry in the list represent exact
   *               one parameter. With this argument the values of the
   *               parameters can contain also comma because these are
   *               not used as separater.
   *
   * @return  The new created ASAM ODS session.
   */
   AoSession newSessionNameValue(
      in NameValueSequence auth)
      raises (AoException);

}; // Interface AoFactory.

/**
* The ASAM ODS session interface.
*/
interface AoSession {

   /** (3001)
   * Abort (rollback) a transaction. The changes made in the transaction
   * are lost.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   */
   void abortTransaction()
      raises (AoException);

   /** (3002)
   * Close session to an ASAM ODS server. Active transactions are
   * committed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void close()
      raises (AoException);

   /** (3003)
   * Commit a transaction. The changes made in the transaction become
   * permanent.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   */
   void commitTransaction()
      raises (AoException);

   /** (3004)
   * Get the application model from the current session by returning an
   * object with the interface ApplicationStructure. The complete
   * information on the application model is available through that
   * interface.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application structure.
   */
   ApplicationStructure getApplicationStructure()
      raises (AoException);

   /** (3005)
   * Get the application model as values from the current session.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application structure as value.
   */
   ApplicationStructureValue getApplicationStructureValue()
      raises (AoException);

   /** (3006)
   * Get the ASAM ODS base model from the current session by returning an
   * object with the interface BaseStructure. The complete information on
   * the base model is available through that interface; it includes all
   * possible base elements with all possible base attributes as
   * specified by ASAM ODS.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The base structure.
   */
   BaseStructure getBaseStructure()
      raises (AoException);

   /** (3007)
   * Get context variables from the session. A pattern string can be
   * specified to select groups of variables.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  varPattern  The name or the search pattern for the context
   *                     variable(s).
   *
   * @return  A list of context variables.
   */
   NameValueIterator getContext(
      in Pattern varPattern)
      raises (AoException);

   /** (3008)
   * Get a context variable by its name from the session.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  varName  The name of the requested context variable.
   *
   * @return  The requested context variable.
   */
   NameValue getContextByName(
      in Name varName)
      raises (AoException);

   /** (3009)
   * List the names of context variables from the session. A pattern
   * string can be specified to select groups of variables.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NOT_FOUND
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  varPattern  The name or the search pattern for the context
   *                     variable(s).
   *
   * @return  A list of context variable names.
   */
   NameIterator listContext(
      in Pattern varPattern)
      raises (AoException);

   /** (3010)
   * Remove context variables from the session. A pattern string can be
   * specified to remove groups of variables.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NOT_FOUND
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  varPattern  The name or the search pattern for the context
   *                     variable(s) to be removed.
   */
   void removeContext(
      in Pattern varPattern)
      raises (AoException);

   /** (3011)
   * Set/modify a known context variable or add a new context variable to
   * the session.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  contextVariable  The context variable.
   */
   void setContext(
      in NameValue contextVariable)
      raises (AoException);

   /** (3012)
   * Set/modify a known context variable or add a new context variable to
   * the session. This is a convenience method for the frequently used
   * string variable type. It uses setContext  internally.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  varName  The name of the context variable.
   *
   * @param  value  The value of the context variable.
   */
   void setContextString(
      in Name varName,
      in T_STRING value)
      raises (AoException);

   /** (3013)
   * Start a transaction on the physical storage system (e.g. database
   * system). Only when a transaction is started it is allowed to create
   * or modify instances or measurement data. The changes get permanent
   * with a commit of the transaction or will be lost with an abort of
   * the transaction. If the session is closed the transaction will be
   * committed automatically. If a transaction is already active an
   * exception is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_ALREADY_ACTIVE
   */
   void startTransaction()
      raises (AoException);

   /** (3014)
   * Make the changes permanent.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   */
   void flush()
      raises (AoException);

   /** (3015)
   * Every new created instance will set its initial rights to <acl> .
   * This method overrides the default-methods for applying initial
   * rights. The initial rights are only valid for the current session.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  irlEntries  The current initial rights.
   *
   * @param  set  Set (1) or remove (0) the current initial rights. The
   *              previous initial rights get lost. If the parameter set
   *              is 0 (remove) the parameter irlEntries will be ignored.
   */
   void setCurrentInitialRights(
      in InitialRightSequence irlEntries,
      in T_BOOLEAN set)
      raises (AoException);

   /** (3016)
   * Get the current lock mode. The lock mode tells the server which
   * objects to lock for upcoming changes. Application elements, instance
   * elements or children of elements can be locked.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The current lock mode. The lock mode constants are defined
   *          in the interface LockMode. The interface definition
   *          language IDL does not allow to set the values of
   *          enumerations thus the constant definitions had to be done
   *          in an interface.
   */
   T_SHORT getLockMode()
      raises (AoException);

   /** (3017)
   * Set the new lock mode. The lock mode tells the server which objects
   * to lock for upcoming changes. Application elements, instance
   * elements or children of elements can be locked.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  lockMode  The new lock mode. The lock mode constants are
   *                   defined in the interface LockMode. The interface
   *                   definition language IDL does not allow to set the
   *                   values of enumerations thus the constant
   *                   definitions had to be done in an interface.
   */
   void setLockMode(
      in T_SHORT lockMode)
      raises (AoException);

   /** (3018)
   * Get the application element access object from the current session.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application element access object.
   */
   ApplElemAccess getApplElemAccess()
      raises (AoException);

   /** (3019)
   * Change the password for user defined by <username> to <newPassword>.
   * A normal user must supply his current password <oldPassword>. The
   * super user can change the password without supplying the current
   * password <oldPassword>. If no username is given the password of the
   * user of the current session will be changed. The password is
   * normally encrypted in the attribute of the user instance element.
   * Creating a new user can be done by creating a new instance,
   * afterwards the password must be set by the super user.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_WRONG_PASSWORD
   *
   * @param  username  The name of the user for which the password will
   *                   be changed. If no username is given the password
   *                   of the current user will be changed. If the
   *                   username differs from the current user the current
   *                   user must be a super user.
   *
   * @param  oldPassword  The current password of the user. A normal user
   *                      must supply his current password. The super
   *                      user can change the password without supplying
   *                      the current password.
   *
   * @param  newPassword  The new password of the user.
   */
   void setPassword(
      in T_STRING username,
      in T_STRING oldPassword,
      in T_STRING newPassword)
      raises (AoException);

   /** (3020)
   * Get the description of the ASAM ODS session. The description of the
   * session is identical with description of the ASAM ODS factory. If
   * the description is not available an empty string is returned and no
   * exception is thrown. The server loads the description from the base
   * attribute "description" of the instance of AoEnvironment.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_CONNECTION_LOST
   *
   * @return  The description of the ASAM ODS session.
   */
   T_STRING getDescription()
      raises (AoException);

   /** (3021)
   * Get the name of the ASAM ODS session. The name of the session is
   * identical with the name of the ASAM ODS factory. If the name is not
   * available an empty string is returned and no exception is thrown.
   * The server loads the name from the base attribute "name" of the
   * instance of AoEnvironment.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_CONNECTION_LOST
   *
   * @return  The name of the ASAM ODS session.
   */
   Name getName()
      raises (AoException);

   /** (3022)
   * Get the type of the ASAM ODS session. The type of the session is
   * identical with the type of the ASAM ODS factory. If the type is not
   * available an empty string is returned and no exception is thrown.
   * The server loads the type from the base attribute
   * "Application_model_type" of the instance of AoEnvironment.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_CONNECTION_LOST
   *
   * @return  The type of the ASAM ODS session.
   */
   T_STRING getType()
      raises (AoException);

   /** (3023)
   * Create a QueryEvaluator object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_ACCESS_DENIED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The new created query evaluator object
   */
   QueryEvaluator createQueryEvaluator()
      raises (AoException);

   /** (3024)
   * Create a new object with the Interface Blob on the server. This
   * object can be used to create an attribute value of the data type
   * DT_BLOB.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The reference of the blob object which is generated at the
   *          server.
   */
   Blob createBlob()
      raises (AoException);

   /** (3025)
   * Create a co session. The co session session is the same session as
   * the original session was at login time.
   * The co session has no relation to the original session except that
   * the same authentication is used.
   * A client application with components can give all components his own
   * session to the ASAM ODS Server. So the component can close the
   * session when it is ready, the component can start his own
   * transaction without any conflict with other components. 
   * Only when the variable CREATE_COSESSION_ALLOWED=TRUE is given in the
   * 'auth' parameter of the method newSession at the interface AoFactory
   * an new session will be created otherwise the exception
   * AO_ACCESS_DENIED is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_ACCESS_DENIED
   *
   * @return  The co session.
   */
   AoSession createCoSession()
      raises (AoException);

   /** (3026)
   * Returns the instance element of the user logged in, this is the
   * instance element from the application element derived from AoUser,
   * with the name given in s given in the 'auth' parameter of the method
   * newSession at the interface AoFactory (variable USER). 
   * 
   * When the client settings of the user are stored in the ASAM ODS
   * application model, this methods helps the client  to get his
   * settings.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The instance element of the logged in user.
   */
   InstanceElement getUser()
      raises (AoException);

   /** (3027)
   * Get the list with the attributes of all elements and the enumeration
   * name which has an enumeration.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @return  The list with attribute and there enumeration.
   */
   EnumerationAttributeStructureSequence getEnumerationAttributes()
      raises (AoException);

   /** (3028)
   * Get all enumerations used in the application model. The enumerations
   * and all items of the enumerations are returned to the client.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The enumeration with there Items.
   */
   EnumerationStructureSequence getEnumerationStructure()
      raises (AoException);

   /** (3029)
   * Returns the Id of the session, the ODS server will give each session
   * an unique Id. The ODS server returns this Id to the client.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *
   * @return  The Id of the session.
   */
   T_LONG getId()
      raises (AoException);

}; // Interface AoSession.

/**
* The ASAM ODS application attribute interface.
*/
interface ApplicationAttribute {

   /** (4001)
   * Get the base attribute of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The base attribute of the application attribute. A 'null'
   *          is returned if the application attribute has no base
   *          attribute.
   */
   BaseAttribute getBaseAttribute()
      raises (AoException);

   /** (4002)
   * Get the data type of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The data type of the application attribute.
   */
   DataType getDataType()
      raises (AoException);

   /** (4003)
   * Get the maximum allowed length of the value of the application
   * attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The maximum allowed length of the application attribute.
   */
   T_LONG getLength()
      raises (AoException);

   /** (4004)
   * Get the name of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the application attribute.
   */
   Name getName()
      raises (AoException);

   /** (4005)
   * Get the unit Id of the application attribute. The unit Id is only
   * valid for the current server.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The unit Id of the application attribute.
   */
   T_LONGLONG getUnit()
      raises (AoException);

   /** (4006)
   * Get the obligatory flag of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The obligatory flag of the application attribute.
   */
   T_BOOLEAN isObligatory()
      raises (AoException);

   /** (4007)
   * Get the unique flag of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The unique flag of the application attribute.
   */
   T_BOOLEAN isUnique()
      raises (AoException);

   /** (4008)
   * Set the base attribute of the application attribute. This allows the
   * client to declare the application attribute (new or existing)
   * additional to a base attribute. The application attribute will
   * become the derived attribute of the given base attribute.
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The base attribute must be unique within the application element
   * otherwise the exception AO_DUPLICATE_BASE_ATTRIBUTE is thrown.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exceptions:
   *    AO_INVALID_DATATYPE
   *    AO_MISSING_VALUE
   *    AO_NOT_UNIQUE.
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the following problems:
   * 
   * AO_INVALID_DATATYPE: The data type of the base attribute is not the
   * same as the data type of the instantiated attributes.
   * 
   * AO_MISSING_VALUE: The obligatory flag of the base attribute is set
   * but there are one or more empty values in the instances.
   * 
   * AO_NOT_UNIQUE: The unique flag of the base attribute is set but the
   * values of the instances are not unique.
   * 
   * The length, the name and the unit of the application attribute are
   * not affected by this call.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_DATATYPE
   *    AO_MISSING_VALUE
   *    AO_NOT_IMPLEMENTED
   *    AO_NOT_UNIQUE
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baseAttr  The base attribute.
   */
   void setBaseAttribute(
      in BaseAttribute baseAttr)
      raises (AoException);

   /** (4009)
   * Set the data type of the application attribute. 
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * It is not allowed to set the data type of application attributes
   * that represent base attributes. An attempt to set the data type of
   * such an application attribute will result in the exception
   * AO_IS_BASE_ATTRIBUTE.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exception:
   *    AO_INVALID_DATATYPE
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the following problem:
   * 
   * AO_INVALID_DATATYPE: The data type of the base attribute is not the
   * same as the data type of the instantiated attributes.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_DATATYPE
   *    AO_IS_BASE_ATTRIBUTE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaDataType  The data type.
   */
   void setDataType(
      in DataType aaDataType)
      raises (AoException);

   /** (4010)
   * Set the obligatory flag of the application attribute.
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * It is not allowed to set the obligatory flag of application
   * attributes
   * that represent base attributes. An attempt to set the obligatory
   * flag of such an application attribute will result in the exception
   * AO_IS_BASE_ATTRIBUTE.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exception:
   *    AO_MISSING_VALUE
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the following problem:
   * 
   * AO_MISSING_VALUE: The obligatory flag of the base attribute is set
   * but there are one or more empty values in the instances.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_IS_BASE_ATTRIBUTE
   *    AO_MISSING_VALUE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaIsObligatory  The obligatory flag.
   */
   void setIsObligatory(
      in T_BOOLEAN aaIsObligatory)
      raises (AoException);

   /** (4011)
   * Set the unique flag of the application attribute. 
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The server will check if the values of the instance attributes are
   * unique. If this flag is set and the values of an attribute are not
   * unique when using the method setValue an exception is thrown. If
   * instances of the application element already exist that contain
   * non-unique values and the flag shall be set this method throws an
   * exception.
   * 
   * It is not allowed to set the unique flag of application attributes
   * that represent base attributes. An attempt to set the unique flag of
   * such an application attribute will result in the exception
   * AO_IS_BASE_ATTRIBUTE.
   * 
   * If the unique flag is set to TRUE the obligatory flag is also set to
   * TRUE. The previous values of both flag do not matter in this case.
   * Setting the unique flag to FALSE does not affect the obligatory
   * flag.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exception:
   *    AO_MISSING_VALUE
   *    AO_NOT_UNIQUE
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the following problem:
   * 
   * AO_MISSING_VALUE: The obligatory flag of the base attribute is set
   * but there are one or more empty values in the instances.
   * 
   * AO_NOT_UNIQUE: The unique flag of the base attribute is set but the
   * values of the instances are not unique.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_IS_BASE_ATTRIBUTE
   *    AO_MISSING_VALUE
   *    AO_NOT_IMPLEMENTED
   *    AO_NOT_UNIQUE
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaIsUnique  The unique flag.
   */
   void setIsUnique(
      in T_BOOLEAN aaIsUnique)
      raises (AoException);

   /** (4012)
   * Set the maximum allowed length of the application attribute. The
   * maximum value  accepted by the ASAM ODS server for this length
   * information depends on the underlying physical storage. For the
   * physical storage specified in chapter 3 the maximum allowed length
   * will be stored in the AFLEN value in SVCATTR, and it is restricted
   * by the maximum length of string type database fields. If a length is
   * specified that exceeds the capabilities of the underlying physical
   * storage the server will throw the exception AO_INVALID_LENGTH. 
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction. 
   * 
   * This method is useful for ODS database design tools. Negative length
   * values are not allowed.
   * 
   * This method provides only a hint to a database server in the design
   * phase which size the data entries may have. The length is only
   * relevant for is ignored for all attribute values with the data type
   * other datatypes than DT_STRING, DS_STRING, DT_DATE, DS_DATE, all
   * components of DT_EXTERNALREFERENCE and of DS_EXTERNALREFERENCE, and
   * the header portion of DT_BLOB.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exception:
   *    AO_HAS_INSTANCES
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the exception AO_HAS_INSTANCES
   * if the instances of the application attribute are not empty.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_INSTANCES
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_LENGTH
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaLength  The maximum attribute length.
   */
   void setLength(
      in T_LONG aaLength)
      raises (AoException);

   /** (4013)
   * Set the name of an application attribute. 
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The name must be unique.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * The name of an application attribute must not exceed the maximum
   * name length of the underlying physical storage. Current server
   * implementations typically restrict it to 30 characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_NAME
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaName  The application attribute name.
   */
   void setName(
      in Name aaName)
      raises (AoException);

   /** (4014)
   * Set the unit Id of an application attribute. 
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The unit Id is only valid for the current server. If instances of
   * the application attribute exist, the respective values are
   * automatically converted to the new unit. If there is no known
   * conversion an exception is thrown.
   * 
   * The automatic conversion can be avoided if the unit is set to zero.
   * After that the transaction must be committed. In the next step the
   * new unit may be set in another transaction.
   * 
   * The automatic conversion is done only for the following data
   * types:
   *    DT_BYTE
   *    DT_COMPLEX
   *    DT_DCOMPLEX
   *    DT_DOUBLE
   *    DT_FLOAT
   *    DT_LONG
   *    DT_LONGLONG
   *    DT_SHORT
   * as well as for the corresponding sequence data types. For complex
   * data types the real and imaginary part are converted separately.
   * 
   * If the unit of an attribute is set the unit is constant. If the
   * value of the attribute has another unit the value is recalculated to
   * the unit of the application attribute. If there is no unit at the
   * application attribute the unit at the attribute value is stored and
   * reported on request at the instance.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   * 
   * If this method is called before the first commit it will not throw
   * the following exceptions:
   *    AO_INCOMPATIBLE_UNITS
   *    AO_MATH_ERROR
   * 
   * After the first commit, there may be instances of the application
   * attribute. These instances may cause the following problems:
   * 
   * AO_INCOMPATIBLE_UNITS: No conversion rules is known to convert the
   * unit.
   * 
   * AO_MATH_ERROR: Converting the values to the new unit results in data
   * overflow or underflow or a division by zero is detected.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INCOMPATIBLE_UNITS
   *    AO_MATH_ERROR
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_UNKNOWN_UNIT
   *
   * @param  aaUnit  The unit Id.
   */
   void setUnit(
      in T_LONGLONG aaUnit)
      raises (AoException);

   /** (4015)
   * The given user group the rights should be set for. <rights> defines
   * the rights to set or to clear. If the parameter <set> is set to
   * 'set', the rights in <rights> are set all others are cleared. If the
   * parameter <set> is set to 'add', the rights in <rights> are added to
   * the existing rights. If the parameter <set> is set to 'remove', the
   * rights in <rights> are removed from the existing rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  usergroup  The user group for which the rights will be
   *                    modified.
   *
   * @param  rights  The new right for the user group. The rights
   *                 constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  set  What to do with the new right.
   */
   void setRights(
      in InstanceElement usergroup,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (4016)
   * Retrieve access control list information of the given object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The access control list entries of the given application
   *          element.
   */
   ACLSequence getRights()
      raises (AoException);

   /** (4017)
   * Return the application element to which the attribute belongs.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application element of the attribute.
   */
   ApplicationElement getApplicationElement()
      raises (AoException);

   /** (4018)
   * Get the auto generate flag of the application attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The auto generate flag of the application attribute.
   */
   T_BOOLEAN isAutogenerated()
      raises (AoException);

   /** (4019)
   * Set the auto generate flag of the application attribute.
   * 
   * It is allowed to modify the application attribute outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * For performance and flexibility reasons this set-method should be
   * used before the new application attribute is committed the first
   * time.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_IS_BASE_ATTRIBUTE
   *    AO_MISSING_VALUE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  isAutogenerated  The auto generate flag.
   */
   void setIsAutogenerated(
      in T_BOOLEAN isAutogenerated)
      raises (AoException);

   /** (4020)
   * Get the definition of the enumeration.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_DATATYPE
   *
   * @return  The ASAM ODS enumeration.
   */
   EnumerationDefinition getEnumerationDefinition()
      raises (AoException);

   /** (4021)
   * Set the definition of the enumeration. This method modifies the
   * application model, only the super user can use this method.
   * 
   * The AoException AO_INVALID_DATATYPE is thrown when the data type of
   * the attribute is not DT_ENUM.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *    AO_INVALID_DATATYPE
   *
   * @param  enumDef  The new enumeration definition.
   */
   void setEnumerationDefinition(
      in EnumerationDefinition enumDef)
      raises (AoException);

   /** (4022)
   * Has the attribute an unit. If this flag is set, all the attributes
   * of the instances derived from this attribute will has an unit.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The flag if the attribute has an unit.
   */
   T_BOOLEAN hasUnit()
      raises (AoException);

   /** (4023)
   * Set whether the attribute becomes an unit or not. A call to the
   * method setUnit() will automatically set the withUnit(TRUE).
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  withUnit  The flag if the attribute becomes an unit.
   */
   void withUnit(
      in T_BOOLEAN withUnit)
      raises (AoException);

   /** (4024)
   * Deprecated, not used any more since ASAM ODS 5.2. 
   * Has the attribute a value flag. If this flag is set, all the
   * attributes of the instances derived from this attribute will has a
   * value flag. If this flag is not set the flag in the TS_Value
   * structure can be ignored.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The flag if the attribute has a value flag.
   */
   T_BOOLEAN hasValueFlag()
      raises (AoException);

   /** (4025)
   * Deprecated, not used any more since ASAM ODS 5.2. 
   * Set whether the attribute becomes a value flag or not. If this flag
   * isn't set the flag of the TS_Value will be ignored by the server.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  withValueFlag  The flag if the attribute becomes a value
   *                        flag.
   */
   void withValueFlag(
      in T_BOOLEAN withValueFlag)
      raises (AoException);

}; // Interface ApplicationAttribute.

/**
* The ASAM ODS application element interface.
*/
interface ApplicationElement {

   /** (5001)
   * Create a new application attribute on the server. 
   * 
   * It is allowed to modify the application element outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The properties of the new application attribute may be changed via
   * the set-methods of the ApplicationAttribute interface.
   * 
   * For performance reasons it is recommended to set all required
   * properties of an application attribute before it is committed the
   * first time. This avoids database cross-checks for each attribute.
   * 
   * The default properties of a new application attribute are:
   *    BaseAttribute   NULL
   *    DataType        DT_UNKNOWN
   *    IsObligatory    0
   *    IsUnique        0
   *    Length          0
   *    Name            "AUTOGEN"
   *    Unit            NULL
   * 
   * If there are already instances of the application element the values
   * of the existing instances of the new attribute are set to
   * undefined.
   * 
   * The exception AO_DUPLICATE_NAME name occurs if there is already
   * another application attribute with the name "AUTOGEN".
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_NAME
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @return  The new application attribute.
   */
   ApplicationAttribute createAttribute()
      raises (AoException);

   /** (5002)
   * Create an instance of the application element. 
   * 
   * It is allowed to create an instance outside a transaction but it is
   * recommended to activate a transaction.
   * 
   * The instance gets permanent when the  transaction is committed.  All
   * attributes connected to the application element are automatically
   * created and connected to the instance. The values of the attributes
   * can be set by the method setValue of the interface InstanceElement.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  ieName  The instance name.
   *
   * @return  The new instance.
   */
   InstanceElement createInstance(
      in Name ieName)
      raises (AoException);

   /** (5003)
   * Get a list of all related application elements connected to this
   * application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The related application elements.
   */
   ApplicationElementSequence getAllRelatedElements()
      raises (AoException);

   /** (5004)
   * Get a list of all application relations connected to this
   * application element. The inverse relation of relations connected to
   * other application elements pointing to the given application
   * elements are not returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application relations of the application element.
   */
   ApplicationRelationSequence getAllRelations()
      raises (AoException);

   /** (5005)
   * Get the application attribute of an application element which is
   * inherited from the base attribute with the given name. The base name
   * is case insensitive and may not contain wildcard characters. 
   * 
   * Note: The base model is case blind,  e.g. Id, ID and id is all the
   * same base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baName  The base attribute name.
   *
   * @return  The application attribute.
   */
   ApplicationAttribute getAttributeByBaseName(
      in Name baName)
      raises (AoException);

   /** (5006)
   * Get the application attribute of an application element which has
   * the given name. The name is case sensitive and may not contain
   * wildcard characters.
   * 
   * Note: The application model is case sensitive, e.g. Id and ID are
   * different application attributes, don't use this misleading
   * attribute name.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaName  The application attribute name.
   *
   * @return  The application attribute.
   */
   ApplicationAttribute getAttributeByName(
      in Name aaName)
      raises (AoException);

   /** (5007)
   * Get a list of the application attributes of an application element.
   * The reference attributes are not returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaPattern  The name or the search pattern for the
   *                    application attribute name.
   *
   * @return  The application attributes.
   */
   ApplicationAttributeSequence getAttributes(
      in Pattern aaPattern)
      raises (AoException);

   /** (5008)
   * Get the base element of an application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The base element.
   */
   BaseElement getBaseElement()
      raises (AoException);

   /** (5009)
   * Get the Id of an application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The Id of the application element.
   */
   T_LONGLONG getId()
      raises (AoException);

   /** (5010)
   * Get the instance element specified by the given Id. If the Id of the
   * instance is not unique an exception is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieId  The instance element Id.
   *
   * @return  The instance element.
   */
   InstanceElement getInstanceById(
      in T_LONGLONG ieId)
      raises (AoException);

   /** (5011)
   * Get the instance element specified by the given name. If the name of
   * the instance is not unique an exception is thrown.
   * 
   * This is a convenience method for instance elements with unique
   * names. If there are duplicate names for instance use the method
   * getInstances instead and specify the requested name as pattern
   * parameter.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_NAME
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieName  The instance element name.
   *
   * @return  The instance element.
   */
   InstanceElement getInstanceByName(
      in Name ieName)
      raises (AoException);

   /** (5012)
   * Get the instances whose names match the pattern. The pattern is case
   * sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  iePattern  The name or the search pattern for the instance
   *                    element name.
   *
   * @return  The instance elements.
   */
   InstanceElementIterator getInstances(
      in Pattern iePattern)
      raises (AoException);

   /** (5013)
   * Get the name of an application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the application element.
   */
   Name getName()
      raises (AoException);

   /** (5014)
   * Get related application elements connected via the specified
   * relationship.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeRelationship  The requested relationship.
   *
   * @return  The related application elements.
   */
   ApplicationElementSequence getRelatedElementsByRelationship(
      in Relationship aeRelationship)
      raises (AoException);

   /** (5015)
   * Get application relations of the requested type connected from this
   * application element. The inverse relations are not returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION_TYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeRelationType  The requested relation type.
   *
   * @return  The application relations.
   */
   ApplicationRelationSequence getRelationsByType(
      in RelationType aeRelationType)
      raises (AoException);

   /** (5016)
   * Get the names of all related application elements.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The names of the related application elements.
   */
   NameSequence listAllRelatedElements()
      raises (AoException);

   /** (5017)
   * Get the application attribute names of the application element.
   * There are no attribute names returned in the result list that
   * contain a reference to another application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaPattern  The name or the search pattern for the
   *                    application attribute name.
   *
   * @return  The names of the application attributes.
   */
   NameSequence listAttributes(
      in Pattern aaPattern)
      raises (AoException);

   /** (5018)
   * Get the names of the instances whose names match the pattern. The
   * pattern is case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aaPattern  The name or the search pattern for the
   *                    application attribute name.
   *
   * @return  The names of the instances.
   */
   NameIterator listInstances(
      in Pattern aaPattern)
      raises (AoException);

   /** (5019)
   * Get the names of related application elements connected via the
   * specified relationship.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeRelationship  The requested relationship.
   *
   * @return  The names of the related application elements.
   */
   NameSequence listRelatedElementsByRelationship(
      in Relationship aeRelationship)
      raises (AoException);

   /** (5020)
   * Remove an application attribute from an application element. If
   * there are instances of the application element the attribute of the
   * existing instances change from application to instance attributes.
   * 
   * 
   * It is allowed to modify the application element outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applAttr  The application attribute to remove.
   */
   void removeAttribute(
      in ApplicationAttribute applAttr)
      raises (AoException);

   /** (5021)
   * Remove an instance from the application element. 
   * 
   * It is allowed to remove an instance outside a transaction but it is
   * recommended to activate a transaction.
   * 
   * The instance is removed from the server when the transaction is
   * committed. If the recursive flag is set all children of the instance
   * are also deleted. Removing instances is allowed only if there are no
   * references(relations) to this instance. If the recursive flag is set
   * a reference to one of the children is not allowed and will cause an
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_REFERENCES
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  ieId  The instance Id.
   *
   * @param  recursive  The recursive flag.
   */
   void removeInstance(
      in T_LONGLONG ieId,
      in T_BOOLEAN recursive)
      raises (AoException);

   /** (5022)
   * Set the base element of the application element. 
   * 
   * It is allowed to modify the application element outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The assignment to the current base element is overwritten. If there
   * are instances of the application element or references to the
   * application element an exception is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_INSTANCES
   *    AO_HAS_REFERENCES
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  baseElem  The base element.
   */
   void setBaseElement(
      in BaseElement baseElem)
      raises (AoException);

   /** (5023)
   * Set the name of the application element.
   *  
   * It is allowed to modify the application element outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The name of the application element must be unique.
   * 
   * The name of an application element must not exceed the maximum name
   * length of the underlying physical storage. Current server
   * implementations restrict it to 30 characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_NAME
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  aeName  The application element name.
   */
   void setName(
      in Name aeName)
      raises (AoException);

   /** (5024)
   * The given user group the rights should be set for. <rights> defines
   * the rights to set or to clear. If the parameter <set> is set to
   * 'set', the rights in <rights> are set all others are cleared. If the
   * parameter <set> is set to 'add', the rights in <rights> are added to
   * the existing rights. If the parameter <set> is set to 'remove', the
   * rights in <rights> are removed from the existing rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  usergroup  The user group for which the rights will be
   *                    modified.
   *
   * @param  rights  The new right for the user group. The rights
   *                 constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  set  What to do with the new right.
   */
   void setRights(
      in InstanceElement usergroup,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (5025)
   * Retrieve access control list information of the given object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The access control list entries of the given application
   *          element.
   */
   ACLSequence getRights()
      raises (AoException);

   /** (5026)
   * Retrieve access control list information for the initial rights of
   * the given object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The access control list entries with the initial rights of
   *          the given application element.
   */
   InitialRightSequence getInitialRights()
      raises (AoException);

   /** (5027)
   * The given user group the initial rights should be set for. <rights>
   * defines the rights to set or to clear. If the parameter <set> is set
   * to 'set', the rights in <rights> are set all others are cleared. If
   * the parameter <set> is set to 'add', the rights in <rights> are
   * added to the existing rights. If the parameter <set> is set to
   * 'remove', the rights in <rights> are removed from the existing
   * rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  usergroup  The user group for which the initial rights will
   *                    be modified.
   *
   * @param  rights  The new initial rights for the user group. The
   *                 rights constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  refAid  The Id of referencing application element for which
   *                 the initial rights will be used. If no refAid is set
   *                 the initial rights will be used for each new
   *                 instance element independent of the application
   *                 element.
   *
   * @param  set  What to do with the new initial rights.
   */
   void setInitialRights(
      in InstanceElement usergroup,
      in T_LONG rights,
      in T_LONGLONG refAid,
      in RightsSet set)
      raises (AoException);

   /** (5028)
   * Set for the given application element, which relation will be used
   * to determine the initial rights for the new created instances.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applRel  The application relation which will be used to
   *                  determine the initial rights. The relation range of
   *                  the application relation must be [1:1] otherwise
   *                  the server can not find an unique instance element
   *                  to retrieve the initial rights.
   *
   * @param  set  Set or remove the relation for the initial rights. If
   *              this parameter is true the relation will be set
   *              otherwise removed.
   */
   void setInitialRightRelation(
      in ApplicationRelation applRel,
      in T_BOOLEAN set)
      raises (AoException);

   /** (5029)
   * Get all relations which are used to retrieve the instances to create
   * the initial rights of the new created instance element. If there are
   * more then one application relation the initial rights of each
   * related instance are 'ored' to the list of the initial rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The sequence with the application relations which will be
   *          used to create the initial rights of the new created
   *          instance element.
   */
   ApplicationRelationSequence getInitialRightRelations()
      raises (AoException);

   /** (5030)
   * Get the security level of the application element. The security
   * level tells if there is a security check for both application
   * element and instance elements or only for the application
   * attributes, the instance elements or none at all.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The current security level. The security level constants
   *          are defined in the interface SecurityLevel. The interface
   *          definition language IDL does not allow to set the values of
   *          enumerations thus the constant definitions had to be done
   *          in an interface.
   */
   T_LONG getSecurityLevel()
      raises (AoException);

   /** (5031)
   * Set the security level for the given application element. If the
   * security level is added the client is responsible for the access
   * control list entries of the existing objects.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  secLevel  The new security level. The security level
   *                   constants are defined in the interface
   *                   SecurityLevel. The interface definition language
   *                   IDL does not allow to set the values of
   *                   enumerations thus the constant definitions had to
   *                   be done in an interface.
   *
   * @param  set  What to do with the new security level.
   */
   void setSecurityLevel(
      in T_LONG secLevel,
      in RightsSet set)
      raises (AoException);

   /** (5032)
   * Get the application model to which the application element belongs
   * by returning an object with the interface ApplicationStructure. The
   * application model provided is the same as that provided from the
   * method getApplicationStructure of the Interface AoSession. This
   * method guarantees that the client software is able to return to the
   * session in case the session object is not available.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application structure to which the application element
   *          belongs.
   */
   ApplicationStructure getApplicationStructure()
      raises (AoException);

   /** (5033)
   * Create a list with instances. The attribute are given with the name
   * of the sequence. The values of the attributes are given in the value
   * sequence. The index in the different value sequences match for one
   * instance element. The index in the instance element sequence of the
   * related instances match for the instance with the same index in the
   * value sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_INVALID_REQUEST
   *
   * @param  attributes  The attributes of the new created instances.
   *
   * @param  relatedInstances  The list with related instances for
   *                           different application relations.
   *
   * @return  The list with the new created instances.
   */
   InstanceElementSequence createInstances(
      in NameValueSeqUnitSequence attributes,
      in ApplicationRelationInstanceElementSeqSequence relatedInstances)
      raises (AoException);

   /** (5034)
   * Return the basic application relations derived from the base
   * relation with the given relation name.
   * Take care at most elements only one application relation can be
   * derived from a base relation, there are some well defined
   * exceptions, so the method can return more then one application
   * relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baseRelName  The name of the base relation.
   *
   * @return  The application relation sequence, if no relation is found
   *          an empty sequence is returned.
   */
   ApplicationRelationSequence getRelationsByBaseName(
      in Name baseRelName)
      raises (AoException);

}; // Interface ApplicationElement.

/**
* The ASAM ODS application relation interface.
* 
* A relation is the connection between two ASAM ODS elements; it may be
* navigated in both
* directions. The get- and set- methods are defined from the first
* element, the getInverse- and
* setInverse- methods work from the second element.
*/
interface ApplicationRelation {

   /** (6001)
   * Get the base relation of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The base relation of the application relation. A 'null' is
   *          returned if the application relation has no base relation.
   */
   BaseRelation getBaseRelation()
      raises (AoException);

   /** (6002)
   * Get the first application element of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The first application element of the application relation.
   */
   ApplicationElement getElem1()
      raises (AoException);

   /** (6003)
   * Get the second application element of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The second application element of the application relation.
   */
   ApplicationElement getElem2()
      raises (AoException);

   /** (6004)
   * Get the inverse relation range of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The inverse relation range of the application relation.
   */
   RelationRange getInverseRelationRange()
      raises (AoException);

   /** (6005)
   * Get the inverse relationship of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The inverse relationship of the application relation.
   */
   Relationship getInverseRelationship()
      raises (AoException);

   /** (6006)
   * Get the name of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the application relation.
   */
   Name getRelationName()
      raises (AoException);

   /** (6007)
   * Get the relation range of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relation range of the application relation.
   */
   RelationRange getRelationRange()
      raises (AoException);

   /** (6008)
   * Get the relationship of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relationship of the application relation.
   */
   Relationship getRelationship()
      raises (AoException);

   /** (6009)
   * Get the relation type of the application relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relation type of the application relation.
   */
   RelationType getRelationType()
      raises (AoException);

   /** (6010)
   * Set the base relation of the application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The relation type and relation range is copied from the base
   * relation. The previous values get lost.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  baseRel  The base relation.
   */
   void setBaseRelation(
      in BaseRelation baseRel)
      raises (AoException);

   /** (6011)
   * Set the first application element of the application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ELEMENT
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applElem  The application element.
   */
   void setElem1(
      in ApplicationElement applElem)
      raises (AoException);

   /** (6012)
   * Set the second application element of the application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ELEMENT
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applElem  The application element.
   */
   void setElem2(
      in ApplicationElement applElem)
      raises (AoException);

   /** (6013)
   * Set the relation range of an application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * It is only allowed to set the relation type if no base relation is
   * defined.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_RELATION
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION_RANGE
   *    AO_IS_BASE_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  arRelationRange  The inverse relation range.
   */
   void setInverseRelationRange(
      in RelationRange arRelationRange)
      raises (AoException);

   /** (6014)
   * Set the name of an application relation.
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The name of an application attribute must not exceed the maximum
   * name length of the underlying physical storage. Current server
   * typically implementations restrict it to 30 characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  arName  The application relation name.
   */
   void setRelationName(
      in Name arName)
      raises (AoException);

   /** (6015)
   * Set the relation range of an application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * It is only allowed to set the relation type if no base relation is
   * defined.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_RELATION
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION_RANGE
   *    AO_IS_BASE_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  arRelationRange  The relation range.
   */
   void setRelationRange(
      in RelationRange arRelationRange)
      raises (AoException);

   /** (6016)
   * Set the relation type of an application relation. 
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The relationship is automatically set when the relation type is set.
   * It is only allowed to set the relation type if no base relation is
   * defined.
   * 
   * It is only allowed to modify a relation type when no base relation
   * is given, otherwise the exception AO_HAS_BASE_RELATION is thrown.
   * 
   * It is not allowed to set the relation type FATHER_CHILD, these
   * relation type is reserved for the base model. The two relation types
   * which can be set are  INFO or INHERITANCE. 
   * 
   * The relationship is set automatic when the relation type is set, the
   * maximum of the relation range determines the relationship between
   * the elements of the relation.
   * 
   * R.Type      | max R.Range | max inv. R.Range | Relationship         
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INFO        | 1           | 1                | exception,
   * AO_INVALID_RELATION_TYPE 
   * ------------+-------------+------------------+-------------         
   *        
   * INFO        | 1           | MANY             | INFO_TO              
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INFO        | MANY        | 1                | INFO_FROM            
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INFO        | MANY        | MANY             | INFO                 
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INHERITANCE | 1           | 1                | exception,
   * AO_INVALID_RELATION_TYPE 
   * ------------+-------------+------------------+-------------         
   *              
   * INHERITANCE | 1           | MANY             | SUPERTYPE            
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INHERITANCE | MANY        | 1                | SUBTYPE              
   *               
   * ------------+-------------+------------------+-------------         
   *              
   * INHERITANCE | MANY        | MANY             | exception,
   * AO_INVALID_RELATION_TYPE
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_BASE_RELATION
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION_TYPE
   *    AO_IS_BASE_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  arRelationType  The relation type.
   */
   void setRelationType(
      in RelationType arRelationType)
      raises (AoException);

   /** (6017)
   * Get the inverse name of the application relation. The inverse name
   * of an application relation is the name of the relation seen from the
   * other application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The inverse name of the application relation.
   */
   Name getInverseRelationName()
      raises (AoException);

   /** (6018)
   * Set the name of an application relation.
   * 
   * It is allowed to modify the application relation outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  arInvName  The inverse application relation name.
   */
   void setInverseRelationName(
      in Name arInvName)
      raises (AoException);

}; // Interface ApplicationRelation.

/**
* The ASAM ODS application structure interface.
*/
interface ApplicationStructure {

   /** (7001)
   * Check the application model for ASAM ODS conformity. The first error
   * found is reported by an exception. The following checks are
   * performed:
   * 
   *  - Each application element must be derived from a valid base
   * element.
   *  - An application attribute is derived from one base attribute. It
   * is not allowed to derive more the one application attribute from the
   * same base attribute. It is allowed that application attributes are
   * not derived from any base attribute.
   *  - All application elements must have at least the mandatory
   * attributes.
   *  - Each application elements must be identified by a unique Asam
   * path. No "floating" application elements are allowed.
   *  - All relations required by the base model must be present.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_BASE_ATTRIBUTE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION
   *    AO_MISSING_ATTRIBUTE
   *    AO_MISSING_RELATION
   *    AO_MISSING_APPLICATION_ELEMENT
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_PATH_TO_ELEMENT
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void check()
      raises (AoException);

   /** (7002)
   * Create a new application element in the application model. 
   * 
   * It is allowed to modify the application model outside a transaction
   * but it is recommended to activate a transaction.
   * 
   * The information whether or not the new application element is a top
   * level element is taken from the specified base element. The Id of
   * the application element is set automatically. The mandatory base
   * attributes are created automatically. Optional attributes have to be
   * created by the calling program. The application attribute interface
   * methods may be used to modify the attributes.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  baseElem  The base element from which the application
   *                   element is derived.
   *
   * @return  The new application element.
   */
   ApplicationElement createElement(
      in BaseElement baseElem)
      raises (AoException);

   /** (7003)
   * Create a new relation. 
   * 
   * It is allowed to modify the application model outside a transaction
   * but it is recommended to activate a transaction.
   * 
   * The relation is part of the application model. The application
   * relation interface methods may be used to modify the relation.
   * 
   * The default properties of a new application relation are:
   *    BaseRelation   NULL
   *    Element1       NULL
   *    Element2       NULL
   *    Range          -2, -2
   *    Name           NULL
   *    Type           INFO
   * When element 1 or element 2 is set before the name of the relation
   * is specified, the name of the application relation is set to
   * "AUTOGEN".
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @return  The new application relation.
   */
   ApplicationRelation createRelation()
      raises (AoException);

   /** (7004)
   * Get the application element with the requested Id.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeId  The Id of the requested application element.
   *
   * @return  The requested application element.
   */
   ApplicationElement getElementById(
      in T_LONGLONG aeId)
      raises (AoException);

   /** (7005)
   * Get the application element with the requested name.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeName  The name of the requested application element.
   *
   * @return  The requested application element.
   */
   ApplicationElement getElementByName(
      in Name aeName)
      raises (AoException);

   /** (7006)
   * Get the application elements whose names match the pattern. The
   * pattern is case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aePattern  The name or the search pattern for the requested
   *                    application elements.
   *
   * @return  The requested application elements.
   */
   ApplicationElementSequence getElements(
      in Pattern aePattern)
      raises (AoException);

   /** (7007)
   * Get the names of application elements that are derived from the
   * specified base element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BASETYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeType  The requested base element type. The base element
   *                 type can be a pattern.
   *
   * @return  The requested application element names.
   */
   ApplicationElementSequence getElementsByBaseType(
      in BaseType aeType)
      raises (AoException);

   /** (7008)
   * Get the instance element specified by the ASAM path.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ASAM_PATH
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  asamPath  The ASAM path of the requested instance element.
   *
   * @return  The requested instance element.
   */
   InstanceElement getInstanceByAsamPath(
      in Name asamPath)
      raises (AoException);

   /** (7009)
   * Returns the relations between two application elements.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  applElem1  The first application element.
   *
   * @param  applElem2  The second application element.
   *
   * @return  The relations between the specified application elements.
   */
   ApplicationRelationSequence getRelations(
      in ApplicationElement applElem1,
      in ApplicationElement applElem2)
      raises (AoException);

   /** (7010)
   * Get the top level application elements which are inherited from the
   * base element that matches the base type. If the given base type is
   * no top level base element an exception is thrown. A top level
   * application element is an application element without a father.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BASETYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeType  The requested base type. The base element type can
   *                 be a pattern.
   *
   * @return  The top level application elements.
   */
   ApplicationElementSequence getTopLevelElements(
      in BaseType aeType)
      raises (AoException);

   /** (7011)
   * Get the names of the application elements that  match the pattern.
   * The pattern is case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aePattern  The name or the search pattern for the requested
   *                    base elements.
   *
   * @return  The names of the application elements.
   */
   NameSequence listElements(
      in Pattern aePattern)
      raises (AoException);

   /** (7012)
   * Get the names of application elements that are  derived from the
   * given base type.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BASETYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeType  The requested base type. The base element type can
   *                 be a pattern.
   *
   * @return  The names of the application elements.
   */
   NameSequence listElementsByBaseType(
      in BaseType aeType)
      raises (AoException);

   /** (7013)
   * Get the names of the top level application elements that are derived
   * from the given base type. If the given base type is not a top level
   * base element an exception is thrown. A top level application element
   * is an application element without a father.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BASETYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aeType  The requested base type.
   *
   * @return  The names of the application elements.
   */
   NameSequence listTopLevelElements(
      in BaseType aeType)
      raises (AoException);

   /** (7014)
   * Remove an application element from the application model. 
   * 
   * It is allowed to modify the application model outside a transaction
   * but it is recommended to activate a transaction.
   * 
   *   - Only allowed:
   *       - if the application element is empty
   *         (has no instances).
   *       - no relations with other application elements.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_INSTANCES
   *    AO_HAS_REFERENCES
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applElem  The application element to be removed.
   */
   void removeElement(
      in ApplicationElement applElem)
      raises (AoException);

   /** (7015)
   * This method removes an application relation from the model. 
   * 
   * It is allowed to modify the application model outside a transaction
   * but it is recommended to activate a transaction.
   * 
   * The elements of the relation are still part of the application
   * model. If there are instances of the relation they are also removed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_HAS_INSTANCES
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  applRel  The application relation to be removed.
   */
   void removeRelation(
      in ApplicationRelation applRel)
      raises (AoException);

   /** (7016)
   * Get the instance elements specified by the element id.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ASAM_PATH
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieIds  The sequence with the element id.
   *
   * @return  The requested instance element sequence.
   */
   InstanceElementSequence getInstancesById(
      in ElemIdSequence ieIds)
      raises (AoException);

   /** (7017)
   * Get the current client session in which the application model is
   * created.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The current client session.
   */
   AoSession getSession()
      raises (AoException);

   /** (7018)
   * Create a new enumeration definition. This method modifies the
   * application model and is only allowed for the super user.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *
   * @param  enumName  Name of the enumeration
   *
   * @return  The new created enumeration
   */
   EnumerationDefinition createEnumerationDefinition(
      in T_STRING enumName)
      raises (AoException);

   /** (7019)
   * Remove the enumeration definition. The server checks if the
   * enumeration is still in use by one of the attributes. This method
   * modifies the application model and is only allowed for the super
   * user.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *
   * @param  enumName  Name of the enumeration to remove.
   */
   void removeEnumerationDefinition(
      in T_STRING enumName)
      raises (AoException);

   /** (7020)
   * Get the list of all enumeration names.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  List with all enumeration names.
   */
   NameSequence listEnumerations()
      raises (AoException);

   /** (7021)
   * Get the specified enumeration definition.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  enumName  Name of the requested enumeration.
   *
   * @return  The enumeration definition.
   */
   EnumerationDefinition getEnumerationDefinition(
      in T_STRING enumName)
      raises (AoException);

   /** (7022)
   * Create the relation between a list of instances. The number of
   * instances in both list must be identical. The application element of
   * the instances in each list must be identical. The application
   * elements must match the application elements of the application
   * relation. The index in the list of the instances defines related
   * instances.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_INVALID_REQUEST
   *
   * @param  applRel  The application relation.
   *
   * @param  elemList1  The list with the instances of one application
   *                    element for which the relation will be created.
   *
   * @param  elemList2  The list with the related instances.
   */
   void createInstanceRelations(
      in ApplicationRelation applRel,
      in InstanceElementSequence elemList1,
      in InstanceElementSequence elemList2)
      raises (AoException);

}; // Interface ApplicationStructure.

/**
* The ASAM ODS base attribute interface.
*/
interface BaseAttribute {

   /** (8001)
   * Get the data type of the base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The data type of the base attribute.
   */
   DataType getDataType()
      raises (AoException);

   /** (8002)
   * Get the name of the base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the base attribute.
   */
   Name getName()
      raises (AoException);

   /** (8003)
   * Get the obligatory flag of the base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The obligatory flag of the base attribute.
   */
   T_BOOLEAN isObligatory()
      raises (AoException);

   /** (8004)
   * Get the unique flag of the base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The unique flag of the base attribute.
   */
   T_BOOLEAN isUnique()
      raises (AoException);

   /** (8005)
   * Return the base element to which the attribute belongs..
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The base element of the attribute.
   */
   BaseElement getBaseElement()
      raises (AoException);

   /** (8006)
   * Get the definition of the enumeration of the base attribute.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_DATATYPE
   *
   * @return  The ASAM ODS enumeration.
   */
   EnumerationDefinition getEnumerationDefinition()
      raises (AoException);

}; // Interface BaseAttribute.

/**
* The ASAM ODS base element interface.
*/
interface BaseElement {

   /** (9001)
   * Get all known relations of the base element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  All known relations of the base element.
   */
   BaseRelationSequence getAllRelations()
      raises (AoException);

   /** (9002)
   * Get attributes of the base element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baPattern  The name or the search pattern for the requested
   *                    base attributes.
   *
   * @return  The requested attributes of the base element.
   */
   BaseAttributeSequence getAttributes(
      in Pattern baPattern)
      raises (AoException);

   /** (9003)
   * Get the related elements of a base element defined by the
   * relationship.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  brRelationship  The requested relationship.
   *
   * @return  The related elements of a base element.
   */
   BaseElementSequence getRelatedElementsByRelationship(
      in Relationship brRelationship)
      raises (AoException);

   /** (9004)
   * Get the base element's relations of the requested relation type.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION_TYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  brRelationType  The requested relation type.
   *
   * @return  The base element's relations of the requested type.
   */
   BaseRelationSequence getRelationsByType(
      in RelationType brRelationType)
      raises (AoException);

   /** (9005)
   * Get the type of the base element. The type of the base element is
   * identical with the name of the base element. The type of the base
   * element is a string.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The type of the base element.
   */
   BaseType getType()
      raises (AoException);

   /** (9006)
   * Get whether or not the base element is a top level element. Top
   * level elements are elements without a father.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Boolean whether or not the base element is a top level
   *          element.
   */
   T_BOOLEAN isTopLevel()
      raises (AoException);

   /** (9007)
   * Get attribute names of the base element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baPattern  The name or the search pattern for the requested
   *                    base attribute names.
   *
   * @return  The requested attribute names of the base element.
   */
   NameSequence listAttributes(
      in Pattern baPattern)
      raises (AoException);

   /** (9008)
   * Get the related element names of the base element defined by the
   * relationship.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  brRelationship  The requested relationship.
   *
   * @return  The related element names of the base element.
   */
   BaseTypeSequence listRelatedElementsByRelationship(
      in Relationship brRelationship)
      raises (AoException);

}; // Interface BaseElement.

/**
* The ASAM ODS base relation interface.
*/
interface BaseRelation {

   /** (10001)
   * Get the first base element of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The first base element of the base relation.
   */
   BaseElement getElem1()
      raises (AoException);

   /** (10002)
   * Get the second base element of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The second base element of the base relation.
   */
   BaseElement getElem2()
      raises (AoException);

   /** (10003)
   * Get the inverse relation range of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The inverse relation range of the base relation.
   */
   RelationRange getInverseRelationRange()
      raises (AoException);

   /** (10004)
   * Get the inverse relationship of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The inverse relationship of the base relation.
   */
   Relationship getInverseRelationship()
      raises (AoException);

   /** (10005)
   * Get the relation name of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relation name of the base relation.
   */
   Name getRelationName()
      raises (AoException);

   /** (10006)
   * Get the relation range of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relation range of the base relation.
   */
   RelationRange getRelationRange()
      raises (AoException);

   /** (10007)
   * Get the relationship of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relationship of the base relation.
   */
   Relationship getRelationship()
      raises (AoException);

   /** (10008)
   * Get the relation type of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The relation type of the base relation.
   */
   RelationType getRelationType()
      raises (AoException);

   /** (10009)
   * Return the inverse name of the base relation.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the inverse relation.
   */
   Name getInverseRelationName()
      raises (AoException);

}; // Interface BaseRelation.

/**
* The ASAM ODS base structure interface.
*/
interface BaseStructure {

   /** (11001)
   * Get the base element that matches the requested type. The type of a
   * base element is identical with the name of the base element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BASETYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  beType  The name of the requested base element.
   *
   * @return  The requested base element.
   */
   BaseElement getElementByType(
      in BaseType beType)
      raises (AoException);

   /** (11002)
   * Get the base elements that match the pattern. The pattern is case
   * sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  bePattern  The name or the search pattern for the requested
   *                    base elements.
   *
   * @return  The requested base elements.
   */
   BaseElementSequence getElements(
      in Pattern bePattern)
      raises (AoException);

   /** (11003)
   * Get the base relation between two base elements. The base relation
   * is given from the first element (parameter elem1) to the second
   * element (parameter elem2), the inverse relation is not given.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @param  elem1  The base element from which the relation starts.
   *
   * @param  elem2  The base element to which the relation points.
   *
   * @return  The base relation between the two base elements.
   */
   BaseRelation getRelation(
      in BaseElement elem1,
      in BaseElement elem2)
      raises (AoException);

   /** (11004)
   * Get the top level base elements that match the pattern. The pattern
   * is case sensitive and may contain wildcard characters. A top level
   * base element is a base element without a father.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  bePattern  The name or the search pattern for the requested
   *                    top level base elements.
   *
   * @return  The requested top level base elements.
   */
   BaseElementSequence getTopLevelElements(
      in Pattern bePattern)
      raises (AoException);

   /** (11005)
   * Get the version of the base model. The version of the base model is
   * the version of the ASAM ODS base model.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The version of the ASAM ODS base model.
   */
   T_STRING getVersion()
      raises (AoException);

   /** (11006)
   * Get the base element names that match the pattern. The pattern is
   * case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  bePattern  The name or the search pattern for the requested
   *                    base element names.
   *
   * @return  The requested base element names.
   */
   BaseTypeSequence listElements(
      in Pattern bePattern)
      raises (AoException);

   /** (11007)
   * Get the top level base element names that match the pattern. The
   * pattern is case sensitive and may contain wildcard characters. A top
   * level base element is a base element without a father.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  bePattern  The name or the search pattern for the requested
   *                    top level base element names.
   *
   * @return  The requested top level base element names.
   */
   BaseTypeSequence listTopLevelElements(
      in Pattern bePattern)
      raises (AoException);

   /** (11008)
   * Get the base relations between two base elements. The base relation
   * is given from the first element (parameter elem1) to the second
   * element (parameter elem2), the inverse relation is not given.
   * When there are no base relation between the two elements the server
   * will throw the exception AO_NOT_FOUND
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @param  elem1  The base element from which the relation starts.
   *
   * @param  elem2  The base element to which the relation points.
   *
   * @return  The list with base relations between the two elements.
   */
   BaseRelationSequence getRelations(
      in BaseElement elem1,
      in BaseElement elem2)
      raises (AoException);

}; // Interface BaseStructure.

/**
* The ASAM ODS blob interface.
*/
interface Blob {

   /** (12001)
   * Append a byte sequence to the binary large object. 
   * 
   * It is allowed to modify the binary large object outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  value  The byte sequence.
   */
   void append(
      in S_BYTE value)
      raises (AoException);

   /** (12002)
   * Compares the content of the binary large object. The headers are not
   * compared.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aBlob  The blob to compare.
   *
   * @return  A flag whether or not the compared blobs are equal.
   */
   T_BOOLEAN compare(
      in T_BLOB aBlob)
      raises (AoException);

   /** (12003)
   * Get a part of the binary large object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  offset  The starting position of the data in the blob.
   *
   * @param  length  The number of bytes requested from the blob.
   *
   * @return  The request part of the blob data.
   */
   S_BYTE get(
      in T_LONG offset,
      in T_LONG length)
      raises (AoException);

   /** (12004)
   * Get the header of the binary large object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The blob header.
   */
   T_STRING getHeader()
      raises (AoException);

   /** (12005)
   * Get the length of the binary large object without loading it.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The blob length.
   */
   T_LONG getLength()
      raises (AoException);

   /** (12006)
   * Clear the binary large object and set the new data. 
   * 
   * It is allowed to modify the binary large object outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  value  The new blob data.
   */
   void set(
      in S_BYTE value)
      raises (AoException);

   /** (12007)
   * Set the header of a binary large object. 
   * 
   * It is allowed to modify the binary large object outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  header  The blob header.
   */
   void setHeader(
      in T_STRING header)
      raises (AoException);

   /** (12008)
   * Destroy the object on the server. The destructor of the client, so
   * the server knows this object is not used anymore by the client.
   * Access to this object after the destroy method will lead to an
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

}; // Interface Blob.

/**
* The ASAM ODS column interface. It is not inherited from
* InstanceElement. Via the method getColumn of the interface SubMatrix
* the column is accessed. The column is only used for read access. With
* the creation of instances at the application element of type
* AoLocalColumn and the relation to the instances of the application
* element of type AoSubMatrix a local column can be created. The column
* name is used for the SMatLink and the column is used to store a formula
* for the calculation of the values of the column. There is no definition
* of the formula language at the moment.
*/
interface Column {

   /** (13001)
   * Get the formula of the column.
   * 
   * There is no formula defined in ASAM ODS, so there is nothing to
   * return.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The formula of the column.
   */
   T_STRING getFormula()
      raises (AoException);

   /** (13002)
   * Get the name of the column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the column.
   */
   Name getName()
      raises (AoException);

   /** (13003)
   * Get the source measurement quantity.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The source measurement quantity.
   */
   InstanceElement getSourceMQ()
      raises (AoException);

   /** (13004)
   * Get the unit of the column.
   * 
   * The method returns the unit of the values according the current
   * setting. Initially within a session this is the unit as given in the
   * storage. After setUnit() is called, the unit as specified by
   * setUnit() will be
   * returned for the particular column. Thus the unit returned will be
   * retrieved by the ODS server according to following strategy:
   * 1) if a unit has already been set for the paricular column by
   * setUnit(..) prior; that unit is returned, else
   * 2) if the related measurement quantity has a unit (i.e. it has a
   * relation derived from the base relation 'unit' referencing an
   * instance of base type AoUnit), that unit's name is returned, else
   * 3) if the related measurement quantity has a relation to a quantity
   * (i.e. its relation derived from the base relation 'quantity' is
   * referencing an instance of base type AoQuantity), and this quantity
   * has
   * a default unit (i.e. it has a relation derived from the base
   * relation 'default_unit' referencing an instance of base type
   * AoUnit), that unit's name is returned, else
   * 4) an empty string is returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The unit of the column.
   */
   T_STRING getUnit()
      raises (AoException);

   /** (13005)
   * Set the formula of the column. 
   * 
   * It is allowed to modify the column outside a transaction but it is
   * recommended to activate a transaction.
   * 
   * There is no formula in ASAM ODS so don't try to set the formula.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  formula  The formula.
   */
   void setFormula(
      in T_STRING formula)
      raises (AoException);

   /** (13006)
   * Set the unit of the column. This is only a temporary unit for
   * getting the values of a column. This unit is not stored in the
   * storage. 
   * When an empty string is given the unit is returned to the original
   * setting.
   * When the value matrix where the column belongs to is in the STORAGE
   * mode this method have no influence on the values returned from the
   * value matrix.
   * To change the unit permanent in the storage the relation at the
   * measurement quantity must be changed by the client.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  unit  The physical unit.
   */
   void setUnit(
      in T_STRING unit)
      raises (AoException);

   /** (13007)
   * Is the column an independent column
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The independent flag of the column.
   */
   T_BOOLEAN isIndependent()
      raises (AoException);

   /** (13008)
   * Deprecated, solved by NVH Application model.
   * 
   * Is the column an scaling column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Tells if the column is a scaling column.
   */
   T_BOOLEAN isScaling()
      raises (AoException);

   /** (13009)
   * Set the column as an independent column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  independent  The new value of the independent flag.
   */
   void setIndependent(
      in T_BOOLEAN independent)
      raises (AoException);

   /** (13010)
   * Deprecated, solved by NVH Application model.
   * 
   * Set the column to a scaling column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  scaling  The new value of the scaling flag.
   */
   void setScaling(
      in T_BOOLEAN scaling)
      raises (AoException);

   /** (13011)
   * Get the data type of the column.
   * The data type of the measurement quantity is always returned,
   * independent of the mode of the values matrix where the column
   * belongs to neither the sequence representation of the column.
   * 
   * This method always returns the data type of the measurement quantity
   * to which this local column belongs, independent of 
   * - the value matrix mode of the value matrices this local column
   * belongs to
   * - the sequence representation of this local column
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The data type of the column.
   */
   DataType getDataType()
      raises (AoException);

   /** (13012)
   * Destroy the object on the server. The destructor of the client so
   * the server knows this object is not used anymore by the client.
   * Access to this object after the destroy method will lead to an
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (13013)
   * Get the sequence representation of the column. 
   * 
   * When the value matrix to which the column belongs is in CALCULATED
   * mode the sequence_representation is always explicit.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The sequence representation of the column. This is the
   *          integer value according the enumeration seq_rep_enum of the
   *          base model.
   */
   T_LONG getSequenceRepresentation()
      raises (AoException);

   /** (13014)
   * Set the sequence representation of a new column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_PARAMETER
   *    AO_TRANSACTION_NOT_ACTVIE
   *
   * @param  sequenceRepresentation  The sequence representation.  This
   *                                 is the integer value according the
   *                                 enumeration seq_rep_enum of the base
   *                                 model.
   */
   void setSequenceRepresentation(
      in T_LONG sequenceRepresentation)
      raises (AoException);

   /** (13015)
   * Get the generation parameters of the Column. 
   * 
   * If no generation parameters exist an empty sequence is returned, its
   * type is double, its length is 0.
   * When the value matrix to which the column belongs is in CALCULATED
   * mode an empty sequence is returned, its type is double, its length
   * is 0.
   * 
   * The data type of the generation parameter for the implicit columns
   * is the data type given at the measurement quantity. The data type of
   * the generation parameters for raw data is always T_DOUBLE.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The generation parameters.
   */
   TS_Union getGenerationParameters()
      raises (AoException);

   /** (13016)
   * Set the generation parameters.
   * 
   * The data type of the generation parameter for the implicit columns
   * must be the data type given at the measurement quantity. The data
   * type of the generation parameters for raw data must be always
   * T_DOUBLE.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_PARAMETER
   *    AO_TRANSACTION_NOT_ACTVIE
   *
   * @param  generationParameters  The generation parameters.
   */
   void setGenerationParameters(
      in TS_Union generationParameters)
      raises (AoException);

   /** (13017)
   * Get the data type of the raw values.
   * 
   * When the column has no raw values the data type of the measurement
   * quantity is returned. 
   * When the value matrix to which the column belongs is in CALCULATED
   * mode the data type of the measurement quantity returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The data type of the raw values.
   */
   DataType getRawDataType()
      raises (AoException);

}; // Interface Column.

/**
* The ASAM ODS instance element interface. It is allowed to modify the
* instances outside a transaction but recommended to activate a
* transaction before the instances are modified. The modifications to
* instances get permanent when the transaction is committed.
*/
interface InstanceElement {

   /** (14001)
   * Add an instance attribute to the instance. The instance attribute is
   * built as a Name/Value/Unit tuple on the client. This method has to
   * copy the data from the client to the server. The name of the
   * attribute must be unique. 
   * 
   * It is allowed to add an instance attribute outside a transaction but
   * it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  instAttr  The instance attribute to be added.
   */
   void addInstanceAttribute(
      in NameValueUnit instAttr)
      raises (AoException);

   /** (14002)
   * Create a relation between the current and the given instance. Check
   * if the application elements of the relation matches the application
   * elements of the instances. 
   * 
   * It is allowed to modify the instance element outside a transaction
   * but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  relation  The application relation.
   *
   * @param  instElem  The instance element.
   */
   void createRelation(
      in ApplicationRelation relation,
      in InstanceElement instElem)
      raises (AoException);

   /** (14003)
   * Get the application element of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The application element from which the instance element is
   *          derived.
   */
   ApplicationElement getApplicationElement()
      raises (AoException);

   /** (14004)
   * Get the ASAM-Path of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The ASAM path to the instance element.
   */
   Name getAsamPath()
      raises (AoException);

   /** (14005)
   * Get the Id of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The Id of the instance element.
   */
   T_LONGLONG getId()
      raises (AoException);

   /** (14006)
   * Get the name of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The name of the instance element.
   */
   Name getName()
      raises (AoException);

   /** (14007)
   * Get the related instances. The application relation and the name of
   * the related  instances specify the listed instances. The pattern is
   * case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  applRel  The application relation.
   *
   * @param  iePattern  The name or the search pattern for the related
   *                    instance names.
   *
   * @return  The related instances.
   */
   InstanceElementIterator getRelatedInstances(
      in ApplicationRelation applRel,
      in Pattern iePattern)
      raises (AoException);

   /** (14008)
   * Get the list of related instances. The relationship and the name of
   * the related instances specify the listed instances. The pattern is
   * case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieRelationship  The requested relationship.
   *
   * @param  iePattern  The name or the search pattern for the related
   *                    instance names.
   *
   * @return  The related instances.
   */
   InstanceElementIterator getRelatedInstancesByRelationship(
      in Relationship ieRelationship,
      in Pattern iePattern)
      raises (AoException);

   /** (14009)
   * Get the attribute value (name, value and unit) of the given
   * attribute of the instance element. This method will not return the
   * value of relation attributes, use the method getRelatedInstances.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  attrName  The name of the requested attribute.
   *
   * @return  The attribute value.
   */
   NameValueUnit getValue(
      in Name attrName)
      raises (AoException);

   /** (14010)
   * Get the attribute value (value and unit) of the attribute inherited
   * from the given base attribute of the instance element. The base name
   * is case insensitive and may not contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  baseAttrName  The base name of the requested attribute.
   *
   * @return  The attribute value.
   */
   NameValueUnit getValueByBaseName(
      in Name baseAttrName)
      raises (AoException);

   /** (14011)
   * Get the attribute names from the instance element. The  attributes
   * reserved for a relation are not listed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ATTRIBUTE_TYPE
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  iaPattern  The name or the search pattern for the attribute
   *                    names.
   *
   * @param  aType  The requested attribute type.
   *
   * @return  The names of the attributes.
   */
   NameSequence listAttributes(
      in Pattern iaPattern,
      in AttrType aType)
      raises (AoException);

   /** (14012)
   * Get the names of the related instances. The application relation and
   * the name of the related instances specifies the listed names. The
   * pattern is case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieRelation  The application relation.
   *
   * @param  iePattern  The name or the search pattern for the related
   *                    instance names.
   *
   * @return  The names of the related instances.
   */
   NameIterator listRelatedInstances(
      in ApplicationRelation ieRelation,
      in Pattern iePattern)
      raises (AoException);

   /** (14013)
   * Get the names of the related instances. The relationship and the
   * name of the related instances specify the listed names. The pattern
   * is case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATIONSHIP
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ieRelationship  The requested relationship.
   *
   * @param  iePattern  The name or the search pattern for the related
   *                    instance names.
   *
   * @return  The names of the related instances.
   */
   NameIterator listRelatedInstancesByRelationship(
      in Relationship ieRelationship,
      in Pattern iePattern)
      raises (AoException);

   /** (14014)
   * Remove an instance attribute.
   * 
   * It is allowed to remove the instance attribute outside a transaction
   * but it is recommended to activate a transaction.
   * 
   * The application attributes can't be removed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  attrName  The name of the attribute to be removed.
   */
   void removeInstanceAttribute(
      in Name attrName)
      raises (AoException);

   /** (14015)
   * Remove the relation between the current instance and the given
   * instance. It is necessary to specify the instance element in case of
   * n:m relations if not all relations shall be deleted. 
   * 
   * It is allowed to modify the instance element outside a transaction
   * but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_RELATION
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  applRel  The relation to be removed.
   *
   * @param  instElem_nm  The instance element for specific delete from
   *                      n:m relations.
   */
   void removeRelation(
      in ApplicationRelation applRel,
      in InstanceElement instElem_nm)
      raises (AoException);

   /** (14016)
   * Rename the instance attribute. The application attributes can't be
   * renamed. 
   * 
   * It is allowed to rename the instance attribute outside a transaction
   * but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_NAME
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  oldName  The old instance attribute name.
   *
   * @param  newName  The new instance attribute name.
   */
   void renameInstanceAttribute(
      in Name oldName,
      in Name newName)
      raises (AoException);

   /** (14017)
   * Set the name of an instance element. 
   * 
   * It is allowed to modify the name of the instance element outside a
   * transaction but it is recommended to activate a transaction.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  iaName  The instance attribute name.
   */
   void setName(
      in Name iaName)
      raises (AoException);

   /** (14018)
   * Set the value of an application attribute or of an existing instance
   * attribute, but is doesn't create a new instance attribute; for this
   * purpose use the method addInstancesAttribute of this interface.
   * 
   * It is allowed to modify the attribute value outside a transaction
   * but it is recommended to activate a transaction.
   * 
   * The name of the attribute is specified by the name of the
   * NameValueUnit tuple. If the application attribute flag unique is
   * set, the uniqueness of the new value is checked.
   * 
   * This method can not be used to set the value of a relation
   * attribute, use the method createRelation of this interface .
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_VALUE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  value  The value to be set in the instance element.
   */
   void setValue(
      in NameValueUnit value)
      raises (AoException);

   /** (14019)
   * Cast an instance element to a measurement. There are some
   * object-oriented languages which do not allow this cast.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_BASETYPE
   *
   * @return  The instance of type measurement.
   */
   Measurement upcastMeasurement()
      raises (AoException);

   /** (14020)
   * Cast an instance element to a submatrix. There are some
   * object-oriented languages which do not allow this cast.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_BASETYPE
   *
   * @return  The instance of type submatrix.
   */
   SubMatrix upcastSubMatrix()
      raises (AoException);

   /** (14021)
   * Get the attribute value (name, value and unit) of the given
   * attribute of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_INCOMPATIBLE_UNITS
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  attr  The name of the requested attribute and the unit of
   *               the attribute value.
   *
   * @return  The attribute value, value converted to the requested unit.
   */
   NameValueUnit getValueInUnit(
      in NameUnit attr)
      raises (AoException);

   /** (14022)
   * Set a sequences of values of an application attributes but no
   * instances attributes.
   * 
   * It is allowed to modify the values of the attributes outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The name of the attribute is specified by the name of the
   * NameValueUnit tuple. If the application attribute flag unique is
   * set, the uniqueness of the new value is checked.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_DUPLICATE_VALUE
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  values  The sequence of the values to be set at the instance
   *                 element.
   */
   void setValueSeq(
      in NameValueUnitSequence values)
      raises (AoException);

   /** (14023)
   * The given user group the rights should be set for. <rights> defines
   * the rights to set or to clear. If the parameter <set> is set to
   * 'set', the rights in <rights> are set all others are cleared. If the
   * parameter <set> is set to 'add', the rights in <rights> are added to
   * the existing rights. If the parameter <set> is set to 'remove', the
   * rights in <rights> are removed from the existing rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  usergroup  The user group for which the rights will be
   *                    modified.
   *
   * @param  rights  The new right for the user group. The rights
   *                 constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  set  What to do with the new right.
   */
   void setRights(
      in InstanceElement usergroup,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (14024)
   * Retrieve access control list information of the given object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The access control list entries of the given application
   *          element.
   */
   ACLSequence getRights()
      raises (AoException);

   /** (14025)
   * Retrieve access control list information for the initial rights of
   * the given object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The access control list entries with the initial rights of
   *          the given application element.
   */
   InitialRightSequence getInitialRights()
      raises (AoException);

   /** (14026)
   * The given user group the initial rights should be set for. <rights>
   * defines the rights to set or to clear. If the parameter <set> is set
   * to 'set', the rights in <rights> are set all others are cleared. If
   * the parameter <set> is set to 'add', the rights in <rights> are
   * added to the existing rights. If the parameter <set> is set to
   * 'remove', the rights in <rights> are removed from the existing
   * rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  usergroup  The user group for which the initial rights will
   *                    be modified.
   *
   * @param  rights  The new initial rights for the user group. The
   *                 rights constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions have to be done in the
   *                 interface.
   *
   * @param  refAid  The Id of referencing application element for which
   *                 the initial rights will be used. If no refAid is set
   *                 the initial rights will be used for each new
   *                 instance element independent of the application
   *                 element.
   *
   * @param  set  What to do with the new initial rights.
   */
   void setInitialRights(
      in InstanceElement usergroup,
      in T_LONG rights,
      in T_LONGLONG refAid,
      in RightsSet set)
      raises (AoException);

   /** (14027)
   * Provides an easy-to-use and effective copy mechanism for instance
   * elements inside the server. The new instance elements gets a copy of
   * all attribute values and informational relations that are available
   * in the original instance element. The new instance element has the
   * same parent as the original instance element but it does not have
   * references to any children of the original instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  newName  The name of the new instance element. If a new
   *                  version shall be created this parameter may be NULL
   *                  to use the same name for the copy. In this case a
   *                  new version must be provided.
   *
   * @param  newVersion  The version of the new instance element. This
   *                     parameter may be NULL if a new name is provided.
   *
   * @return  The reference to the copied instance element.
   */
   InstanceElement shallowCopy(
      in T_STRING newName,
      in T_STRING newVersion)
      raises (AoException);

   /** (14028)
   * Provides an easy-to-use and effective copy mechanism for instance
   * element hierarchies inside the server (e.g. copy a project with all
   * tests or copy a test with all measurements). The deep copy follows
   * only the child references but not the informational references.
   * Example: Copying elements of type AoMeasurement does not include
   * copying the referenced elements of type AoMeasurementQuantity. The
   * copied instance elements of type AoMeasurement will reference the
   * same measurement quantities as the original. An application that
   * wants to copy the measurement quantity also must do this (including
   * setting the proper references) by itself e.g. with another call to
   * shallowCopy; deepCopy is not necessary in this case because
   * AoMeasurementQuantity has no children.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  newName  The name of the new instance element. If a new
   *                  version shall be created this parameter may be NULL
   *                  to use the same name for the copy. In this case a
   *                  new version must be provided.
   *
   * @param  newVersion  The version of the new instance element. This
   *                     parameter may be NULL if a new name is provided.
   *
   * @return  The reference to the copied instance element hierarchy.
   */
   InstanceElement deepCopy(
      in T_STRING newName,
      in T_STRING newVersion)
      raises (AoException);

   /** (14029)
   * Get the sequence of the values of the application or instance
   * attributes, specified by their names.  The name sequence can use a
   * pattern (*) for all attributes of the instance element. This means
   * that application as well as   instance attributes will be delivered.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  attrNames  The names of the attributes to be reported.
   *
   * @return  The sequence of the attribute values.
   */
   NameValueUnitSequence getValueSeq(
      in NameSequence attrNames)
      raises (AoException);

   /** (14030)
   * Destroy the object on the server. The destructor of the client so
   * the server knows this object is not used anymore by the client.
   * Access to this object after the destroy method will lead to an
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (14031)
   * Compare two instance elements. The Id's of the application elements
   * and the Id's of the instance elements are compared. The Id's of the
   * application elements will be compare first.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  compIeObj  The instance element to compare with.
   *
   * @return  The difference of the Id's. Meaning:
   *          diff < 0 ElemId of instance is smaller then instance to
   *          compare with.
   *          diff == 0 ElemId is identical.
   *          diff > 0 ElemId of instance is greater then instance to
   *          compare with.
   */
   T_LONGLONG compare(
      in InstanceElement compIeObj)
      raises (AoException);

   /** (14032)
   * Create a list with instances which are related to the actual
   * instance element. The attribute are given with the name of the
   * sequence. The values of the attributes are given in the value
   * sequence. The index in the different value sequences match for one
   * instance element. The index in the instance element sequence of the
   * related instances match for the instance with the same index in the
   * value sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_INVALID_REQUEST
   *
   * @param  applRel  The application relation for witch the related
   *                  instances will be created.
   *
   * @param  attributes  The attributes of the new created instances.
   *
   * @param  relatedInstances  The list with related instances for
   *                           different application relations.
   *
   * @return  The list with the new created instances.
   */
   InstanceElementSequence createRelatedInstances(
      in ApplicationRelation applRel,
      in NameValueSeqUnitSequence attributes,
      in ApplicationRelationInstanceElementSeqSequence relatedInstances)
      raises (AoException);

   /** (14033)
   * Upcast the InstanceElement object to the corresponding ODSFile
   * interface for an instance. 
   * 
   * This method may only be invoked for instances of an application
   * element derived from
   * the base element AoFile and returns an ODSFile interface.
   * 
   * An exception with the error code AO_INVALID_BASETYPE is thrown when
   * the instance is not an instance of an application element derived
   * from the base element AoFile.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_INVALID_BASETYPE
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The ODSFile interface to access the desired file.
   */
   ODSFile upcastODSFile()
      raises (AoException);

}; // Interface InstanceElement.

/**
* The ASAM ODS instance element iterator interface.
*/
interface InstanceElementIterator {

   /** (15001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (15002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (15003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n instance elements from the instance sequence.
   */
   InstanceElementSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (15004)
   * Get the next element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next instance element from the instance sequence.
   */
   InstanceElement nextOne()
      raises (AoException);

   /** (15005)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface InstanceElementIterator.

/**
* The ASAM ODS measurement interface.The interface Measurement extends
* the interface InstanceElement. Thus alll methods of the interface
* InstanceElement do also work here.
*/
interface Measurement : InstanceElement {

   /** (16001)
   * Create a submatrix link. The submatrix link is only valid in the
   * current session. When the session is closed the submatrix link will
   * be destroyed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The new submatrix link.
   */
   SMatLink createSMatLink()
      raises (AoException);

   /** (16002)
   * Get the list of the submatrix links .
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The available submatrix links.
   */
   SMatLinkSequence getSMatLinks()
      raises (AoException);

   /** (16003)
   * Get the value matrix of a measurement. 
   * By calling this method, the value matrix mode of the returned value
   * matrix will be taken from the context variable 'VALUEMATRIX_MODE'.
   * For more information especially on different modes of the value
   * matrix, see description at the method getValueMatrixInMode() of this
   * interface.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_VALUEMATRIX_STRUCTURE
   *
   * @return  The value matrix.
   */
   ValueMatrix getValueMatrix()
      raises (AoException);

   /** (16004)
   * Remove a submatrix link.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  smLink  The sub matrix link to be removed.
   */
   void removeSMatLink(
      in SMatLink smLink)
      raises (AoException);

   /** (16005)
   * Get the value matrix of a measurement in the requested mode.
   * 
   * The server checks the independent column, if there is more than one
   * submatrix at the measurement there must be exactly one independent
   * column with the same measurement quantity in each submatrix,
   * otherwise the exception AO_INVALID_VALUEMATRIX_STRUCTURE is
   * thrown.
   * 
   * The server throws the exception AO_INVALID_VALUEMATRIX_STRUCTURE
   * when it is unable to create the value matrix due to the data of the
   * measurement
   * - if there are no independent column
   * - if there are different independent columns
   * - if there are sub matrices with more than one independent column.
   * 
   * The server orders the values according to the values of the
   * independent localcolumn. (in ascending order) It is up to the server
   * what value is returned when a measurement quantity has two different
   * values at the same independent point. The gaps are marked with Flags
   * in TS_ValueSeq (flagvalue = 0).
   * 
   * In the CALCULATED mode the server returns the calculated values for
   * implicit and raw values. The server returns at each measurement
   * point the explicit value as the value for the implicit channels. The
   * raw values are calculated to the explicit values.
   * 
   * In the STORAGE mode the server handles the values of the localcolumn
   * as they are in the storage. Write is only allowed when the value
   * matrix is in the STROAGE mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_VALUEMATRIX_STRUCTURE
   *
   * @param  vmMode  The requested mode of the value matrix.
   *
   * @return  The value matrix.
   */
   ValueMatrix getValueMatrixInMode(
      in ValueMatrixMode vmMode)
      raises (AoException);

}; // Interface Measurement.

/**
* The ASAM ODS name iterator interface.
*/
interface NameIterator {

   /** (17001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (17002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (17003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n names from the name sequence.
   */
   NameSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (17004)
   * Get the next element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next name from the name sequence.
   */
   Name nextOne()
      raises (AoException);

   /** (17005)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface NameIterator.

/**
* The ASAM ODS name-value iterator interface.
*/
interface NameValueIterator {

   /** (18001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (18002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (18003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n name-value pairs from the name-value pair
   *          sequence.
   */
   NameValueSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (18004)
   * Get the next element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next name-value pair from the name-value pair sequence.
   */
   NameValue nextOne()
      raises (AoException);

   /** (18005)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface NameValueIterator.

/**
* The ASAM ODS name-value-unit iterator interface. This interface is
* identical with the NameValueUnitIdIterator, except the unit is given as
* a string insead of an Id.
*/
interface NameValueUnitIterator {

   /** (19001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (19002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (19003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n name-value-unit tuples from the name-value-unit
   *          tuple sequence.
   */
   NameValueUnitSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (19004)
   * Get the next element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next name-value-unit tuple from the name-value-unit
   *          tuple sequence.
   */
   NameValueUnit nextOne()
      raises (AoException);

   /** (19005)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface NameValueUnitIterator.

/**
* The ASAM ODS submatrix link interface.
*/
interface SMatLink {

   /** (20001)
   * Get the link or build type.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The link type.
   */
   BuildUpFunction getLinkType()
      raises (AoException);

   /** (20002)
   * Get the ordinal or sequence number
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The sequence number.
   */
   T_LONG getOrdinalNumber()
      raises (AoException);

   /** (20003)
   * Get the first submatrix of the link.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The first submatrix of the link.
   */
   SubMatrix getSMat1()
      raises (AoException);

   /** (20004)
   * Get the bind columns of the first submatrix used in the link (e.g.
   * Time).
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The columns of the first submatrix.
   */
   ColumnSequence getSMat1Columns()
      raises (AoException);

   /** (20005)
   * Get the second submatrix of the link.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The second submatrix of the link.
   */
   SubMatrix getSMat2()
      raises (AoException);

   /** (20006)
   * Get the bind columns of the second submatrix used in the link (e.g.
   * Time).
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The columns of the second submatrix.
   */
   ColumnSequence getSMat2Columns()
      raises (AoException);

   /** (20007)
   * Set the build or link type.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_BUILDUP_FUNCTION
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  linkType  The requested build-up function.
   */
   void setLinkType(
      in BuildUpFunction linkType)
      raises (AoException);

   /** (20008)
   * Set the ordinal or sequence number.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_ORDINALNUMBER
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  ordinalNumber  The sequence number.
   */
   void setOrdinalNumber(
      in T_LONG ordinalNumber)
      raises (AoException);

   /** (20009)
   * Set the first submatrix of the link.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_SUBMATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  subMat1  The first sub matrix of the sub matrix link.
   */
   void setSMat1(
      in SubMatrix subMat1)
      raises (AoException);

   /** (20010)
   * Set the bind columns of the first submatrix used in the link (e.g.
   * Time).
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COLUMN
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  columns  The column sequence of the sub matrix.
   */
   void setSMat1Columns(
      in ColumnSequence columns)
      raises (AoException);

   /** (20011)
   * Set the second submatrix of the link.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_INVALID_SUBMATRIX
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  subMat2  The second sub matrix of the sub matrix link.
   */
   void setSMat2(
      in SubMatrix subMat2)
      raises (AoException);

   /** (20012)
   * Set the bind columns of the second submatrix used in the link (e.g.
   * Time). If there is more than one column bound the column sequence
   * must be identical with the column sequence of the first submatrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_INVALID_COLUMN
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  columns  The column sequence of the sub matrix.
   */
   void setSMat2Columns(
      in ColumnSequence columns)
      raises (AoException);

}; // Interface SMatLink.

/**
* The ASAM ODS submatrix interface. The instances of the submatrix can be
* accessed via the method getRelatedInstances of the interface
* Measurement. The interface SubMatrix extends the interface
* InstanceElement. Thus alll methods of the interface InstanceElement do
* also work here.
*/
interface SubMatrix : InstanceElement {

   /** (21001)
   * Get the columns of the submatrix. The column is not inherited from
   * the InstanceElement interface. This is the only way to get a column.
   * The columns are used in the SMatLink interface to build the value
   * matrix. The pattern is case sensitive and may contain wildcard
   * characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the column
   *                     names.
   *
   * @return  The columns of the submatrix.
   */
   ColumnSequence getColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (21002)
   * Get a value matrix of the submatrix.
   * By calling this method, the value matrix mode of the returned value
   * matrix will be taken from the context variable 'VALUEMATRIX_MODE'.
   * For more information especially on different modes of the value
   * matrix, see description at the method getValueMatrixInMode() of this
   * interface.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_SMATLINK
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The value matrix.
   */
   ValueMatrix getValueMatrix()
      raises (AoException);

   /** (21003)
   * Get the names of the columns of the submatrix. The name sequence is
   * identical with the names of the related instances. The pattern is
   * case sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the column
   *                     names.
   *
   * @return  The column names of the submatrix.
   */
   NameSequence listColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (21004)
   * Get the value matrix of a submatrix in the requested mode.
   * 
   * The server doesn't check any independent columns. The columns are
   * only the local columns from this submatrix. The flags in the
   * TS_ValueSeq are the flags of the localcolumn. If no flags are given
   * there are no flags available, the client have to check the
   * global_flag.
   * 
   * In the CALCULATED mode the server returns the calculated values for
   * implicit and raw values. The server returns at each measurement
   * point the explicit value as the value for the implicit channels. The
   * raw values are calculated to the explicit values.
   * 
   * In the STORAGE mode the server handles the values of the localcolumn
   * as they are in the storage. Write is only allowed when the value
   * matrix is in the STROAGE mode. The values are exactly from this
   * submatrix. The raw / implicit values are returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  vmMode  The requested mode of the value matrix.
   *
   * @return  The value matrix.
   */
   ValueMatrix getValueMatrixInMode(
      in ValueMatrixMode vmMode)
      raises (AoException);

}; // Interface SubMatrix.

/**
* The ASAM ODS value matrix interface. Value matrix is an interface used
* by Measurement and SubMatrix to handle vectors of values.
*/
interface ValueMatrix {

   /** (22001)
   * Get the columns of the value matrix no matter whether the column is
   * dependent or independent. The pattern is case sensitive and may
   * contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the column
   *                     names.
   *
   * @return  The columns of the value matrix, no matter whether the
   *          column is dependent, independent or scaling
   */
   ColumnSequence getColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22002)
   * Get the column count of the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of columns of the value matrix.
   */
   T_LONG getColumnCount()
      raises (AoException);

   /** (22003)
   * Get the independent columns of the value matrix. The independent
   * columns are the columns used to build the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the
   *                     independent column name.
   *
   * @return  The independent column of the value matrix.
   */
   ColumnSequence getIndependentColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22004)
   * Get the row count of the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of rows of the value matrix.
   */
   T_LONG getRowCount()
      raises (AoException);

   /** (22005)
   * Get a measurement point of the value matrix. The parameter meaPoint
   * specifies the row of the matrix. The iterator allows to access all
   * elements in the row.
   * 
   * The server behavior depends on the mode of the value matrix.
   * Value matrix mode 'CALCULATED':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will first calculate the physical values from raw values and
   * generation parameters, before it returns them to the requesting
   * client.
   * Value matrix mode 'STORAGE':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will return the raw values of the local column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  meaPoint  The measurement point.
   *
   * @return  The requested measurement point.
   */
   NameValueUnitIterator getValueMeaPoint(
      in T_LONG meaPoint)
      raises (AoException);

   /** (22006)
   * Get the values or a part of values of the column from the value
   * matrix. The parameter column specifies from which column the values
   * will be returned. The startPoint and count specify the part of the
   * vector. A startPoint = 0 and count = rowCount will return the entire
   * vector. When startPoint >= rowCount an exception is thrown. If
   * startPoint + count > rowCount only the remaining values of the
   * vector are returned and no exception is thrown. Use the getName and
   * getUnit method of the interface column for the name and the unit of
   * the column. The name and the value are not stored at each element of
   * the vector. The return type TS_ValueSeq is not a sequence of
   * TS_Value but a special structure.
   * 
   * The server behavior depends on the mode of the value matrix.
   * Value matrix mode 'CALCULATED':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will first calculate the physical values from raw values and
   * generation parameters, before it returns them to the requesting
   * client.
   * Value matrix mode 'STORAGE':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will return the raw values of the local column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COLUMN
   *    AO_INVLAID_COUNT
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  col  The column to retrieve the values from.
   *
   * @param  startPoint  The starting point in the column.
   *
   * @param  count  The number of points to be retrieved.
   *
   * @return  The requested column values of the value matrix.
   */
   TS_ValueSeq getValueVector(
      in Column col,
      in T_LONG startPoint,
      in T_LONG count)
      raises (AoException);

   /** (22007)
   * Get the names of the columns of the value matrix no matter whether
   * the column is dependent or independent. The pattern is case
   * sensitive and may contain wildcard characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the column
   *                     names.
   *
   * @return  The column names of the value matrix, no matter whether the
   *          column is dependent, independent or scaled by another one.
   */
   NameSequence listColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22008)
   * Get the names of the independent columns of the value matrix. The
   * independent columns are the columns used to build the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the
   *                     independent column name.
   *
   * @return  The names of the independent columns of the value matrix.
   */
   NameSequence listIndependentColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22009)
   * Remove the values of the columns at a given measurement point.
   * Remove the number of points of the given column. If the count is 0
   * all points until the end of the column are removed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COUNT
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  columnNames  The columns from which the measurement points
   *                      are to be removed.
   *
   * @param  meaPoint  The measurement point to be removed.
   *
   * @param  count  The number of points to be removed from each column.
   */
   void removeValueMeaPoint(
      in NameSequence columnNames,
      in T_LONG meaPoint,
      in T_LONG count)
      raises (AoException);

   /** (22010)
   * Remove the values from a value vector. Beginning at startPoint the
   * number of values specified in count are removed. If count is 0 all
   * values from  the startPoint until the end of the vector are removed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COLUMN
   *    AO_INVALID_COUNT
   *    AO_NOT_FOUND
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  col  The column from which the values are to be removed.
   *
   * @param  startPoint  The starting point for the value removal.
   *
   * @param  count  The number of points to be removed from the column.
   */
   void removeValueVector(
      in Column col,
      in T_LONG startPoint,
      in T_LONG count)
      raises (AoException);

   /** (22011)
   * Create or modify a measurement point of a value matrix. 
   * The sequence of name values specifies the names of the column with
   * the new values. 
   * The meaning of the parameter setType is:
   * 
   *    INSERT   Insert the values at meaPoint, the current values at
   * meaPoint    are moved to the end of  the new inserted values.
   * 
   *    APPEND   The value of meaPoint is ignored, the values are
   * appended at the end of the current values.
   * 
   *    UPDATE   Update or modify the values at meaPoint, the current
   * values are overwritten. If meaPoint is bigger than the number of
   * values in the          vector, the measurement point is
   * automatically appended.
   * 
   * The names of the columns have to exist.
   * 
   * When a client creates a ValueMatrix based on AoMeasurement this
   * methods behaves as follows:
   * The server checks the sub matrices and creates all necessary
   * instances of AoSubmatrix, AoLocalColumn and AoMeasurementQuantity. 
   * The values of the name attribute of AoSubmatrix must be generated by
   * the server. The value will be equal to the value of the attribute ID
   * (converted to DT_STRING). Missing instances of AoMeasurementQuantity
   * will be created by the server, too. 
   * 
   * The mandatory attributes will get the following default values:
   * Name supplied by client 
   * Datatype copied from AoQuantity.default_datatype
   * Typesize copied from AoQuantity.default_typesize
   * Interpolation no interpolation
   * Rank copied from AoQuantity.default_rank
   * Dimension copied from AoQuantity.default_dimension
   * 
   * The server takes the value of the channel (supplied by client) and
   * looks up the corresponding instance in AoQuantity using the
   * attribute default_meq_name.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_IS_MEASUREMENT_MATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  set  The set type.
   *
   * @param  meaPoint  The measurement point.
   *
   * @param  value  The values to be inserted.
   */
   void setValueMeaPoint(
      in SetType set,
      in T_LONG meaPoint,
      in NameValueSequence value)
      raises (AoException);

   /** (22012)
   * Create or modify a value vector in a value matrix. 
   * 
   * It is allowed to modify the values of the value matrix outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The data is made permanent on transaction commit. Until the
   * transaction is committed or until the access to the measurement
   * point of the value matrix, it is allowed to have different number of
   * values in the different value vectors.
   * 
   * The meaning of the parameter setType is:
   * 
   *    INSERT   Insert the values from startPoint, the current available
   * values from startPoint are moved to the end of the new inserted
   * values.
   * 
   *    APPEND   The value of startPoint is ignored,  the values are
   * appended at the end of the current values.
   * 
   *    UPDATE   Update or modify the values from startPoint, the current
   * values are overwritten. If the number of values in the parameter
   * values is too big    the values are automatically appended.
   * 
   * When a client creates a ValueMatrix based on AoMeasurement this
   * methods 
   * behaves as follows:
   * The server checks the sub matrices and creates all necessary
   * instances of AoSubmatrix, AoLocalColumn and AoMeasurementQuantity. 
   * The values of the name attribute of AoSubmatrix must be generated by
   * the server. The value will be equal to the value of the attribute ID
   * (converted to DT_STRING). Missing instances of AoMeasurementQuantity
   * will be created by the server, 
   * too. 
   * 
   * The mandatory attributes will get the following default values:
   * Name supplied by client 
   * Datatype copied from AoQuantity.default_datatype
   * Typesize copied from AoQuantity.default_typesize
   * Interpolation no interpolation
   * Rank copied from AoQuantity.default_rank
   * Dimension copied from AoQuantity.default_dimension
   * 
   * The server takes the value of the channel (supplied by client) and
   * looks up the corresponding instance in AoQuantity using the
   * attribute default_meq_name.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COLUMN
   *    AO_INVALID_SET_TYPE
   *    AO_IS_MEASUREMENT_MATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  col  The column whose values are to be set.
   *
   * @param  set  The set type.
   *
   * @param  startPoint  The starting point for the new values.
   *
   * @param  value  The values to be inserted.
   */
   void setValueVector(
      in Column col,
      in SetType set,
      in T_LONG startPoint,
      in TS_ValueSeq value)
      raises (AoException);

   /** (22013)
   * Create or modify a number of value vectors in a value matrix. 
   * 
   * It is allowed to modify the values of the value matrix outside a
   * transaction but it is recommended to activate a transaction.
   * 
   * The data is made permanent on transaction commit. Until the
   * transaction is committed or until the access to the measurement
   * point of the value matrix it is allowed to have different numbers of
   * values in the different value vectors.
   * 
   * The names of the parameter values are the names of the columns. The
   * values are the new values of the column. (setValueMeaPoint allows
   * only one point, the TS_ValueSeq allows more then one point) There is
   * a sequence of name value pairs (setValueVector allows only one
   * column), so a block of values can be modified.
   * 
   * The meaning of the parameter setType is:
   * 
   *    INSERT   Insert the values from startPoint,  the current
   * available values from  startPoint are moved to the end of  the new
   * inserted values.
   * 
   *    APPEND   The value of startPoint is ignored, the values are
   * appended at the end of the current values.
   * 
   *    UPDATE   Update or modify the values from startPoint, the current
   * values are overwritten. If the number of values is greater than the
   * number of values in the  vector, the measurement point is 
   * automatically appended.
   * 
   *    REMOVE  Remove the number of values from each column, starting
   * with startPoint. The name of the column is given as the name of the
   * NameValueseqUnit, the  number of values to remove is given  in the
   * number of the values in the   value.
   * 
   * When a client creates a ValueMatrix based on AoMeasurement this
   * methods behaves as follows:
   * The server checks the sub matrices and creates all necessary
   * instances of AoSubmatrix, AoLocalColumn and AoMeasurementQuantity. 
   * The values of the name attribute of AoSubmatrix must be generated by
   * the server. The value will be equal to the value of the attribute ID
   * (converted to DT_STRING). Missing instances of AoMeasurementQuantity
   * will be created by the server, too. 
   * 
   * The mandatory attributes will get the following default values:
   * Name supplied by client 
   * Datatype copied from AoQuantity.default_datatype
   * Typesize copied from AoQuantity.default_typesize
   * Interpolation no interpolation
   * Rank copied from AoQuantity.default_rank
   * Dimension copied from AoQuantity.default_dimension
   * 
   * The server takes the value of the channel (supplied by client) and
   * looks up the corresponding instance in AoQuantity using the
   * attribute default_meq_name.
   * 
   * The ValueMatrix interface handles the values but not the raw values,
   * to modify the raw values the instances of localcolumn must be
   * created, the base attribute sequence_representation, raw_datatype
   * and the generation_parameter must be created before the values are
   * modified. The values must have the data type identical with the
   * raw_datatype, any other data type will cause an AO_INVALID_DATATYPE
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_COLUMN
   *    AO_INVALID_SET_TYPE
   *    AO_INVALID_DATATYPE
   *    AO_IS_MEASUREMENT_MATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  set  The set type.
   *
   * @param  startPoint  The measurement point.
   *
   * @param  value  The values to be inserted.
   */
   void setValue(
      in SetType set,
      in T_LONG startPoint,
      in NameValueSeqUnitSequence value)
      raises (AoException);

   /** (22014)
   * Add a column to the value matrix. It is only allowed to create a
   * value vector if the value matrix is created from a submatrix. 
   * 
   * It is allowed to add a column outside a transaction but it is
   * recommended to activate a transaction.
   * 
   * The data is made permanent on transaction commit. Until the
   * transaction is committed or until the access to the measurement
   * point of the value matrix it is allowed to have different number of
   * values in the different value vectors. After the new column is
   * added, it is possible to set the values of the column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_NAME
   *    AO_INVALID_SET_TYPE
   *    AO_IS_MEASUREMENT_MATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  newColumn  The name and unit of the column to add.
   *
   * @return  The new column.
   */
   Column addColumn(
      in NameUnit newColumn)
      raises (AoException);

   /** (22015)
   * Deprecated, solved by NVH Application model.
   * 
   * Get the names of the scaling columns of the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the scaling
   *                     column name.
   *
   * @return  The names of the scaling columns of the value matrix.
   */
   NameSequence listScalingColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22016)
   * Deprecated, solved by NVH Application model.
   * 
   * Get the scaling column of the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  colPattern  The name or the search pattern for the scaling
   *                     column name.
   *
   * @return  The scaling columns of the value matrix.
   */
   ColumnSequence getScalingColumns(
      in Pattern colPattern)
      raises (AoException);

   /** (22017)
   * Deprecated, solved by NVH Application model.
   * 
   * List the names of the columns, which are scaled by the given column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NO_SCALING_COLUMN
   *
   * @param  scalingColumn  The scaling column.
   *
   * @return  The names of the columns which are scaled by the given
   *          input column.
   */
   NameSequence listColumnsScaledBy(
      in Column scalingColumn)
      raises (AoException);

   /** (22018)
   * Deprecated, solved by NVH Application model.
   * 
   * Get the columns which are scaled by the given column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NO_SCALING_COLUMN
   *
   * @param  scalingColumn  The scaling column.
   *
   * @return  The columns which are scaled by the given input column.
   */
   ColumnSequence getColumnsScaledBy(
      in Column scalingColumn)
      raises (AoException);

   /** (22019)
   * Deprecated, solved by NVH Application model.
   * 
   * Add a column to the value matrix. It is only allowed to create a
   * value vector if the value matrix is created from a submatrix. The
   * column will be scaled by the given scaling column.
   * 
   * It is allowed to add a column outside a transaction but it is
   * recommended to activate a transaction.
   * 
   * The data is made permanent on transaction commit. Until the
   * transaction is committed or until the access to the measurement
   * point of the value matrix it is allowed to have different number of
   * values in the different value vectors. After the new column is
   * added, it is possible to set the values of the column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_INVALID_NAME
   *    AO_INVALID_SET_TYPE
   *    AO_IS_MEASUREMENT_MATRIX
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NO_SCALING_COLUMN
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  newColumn  The name and unit of the column to add.
   *
   * @param  scalingColumn  The scaling column.
   *
   * @return  The new column.
   */
   Column addColumnScaledBy(
      in NameUnit newColumn,
      in Column scalingColumn)
      raises (AoException);

   /** (22020)
   * Destroy the object on the server. The destructor of the client, so
   * the server knows this object is not used anymore by the client.
   * Access to this object after the destroy method will lead to an
   * exception.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (22021)
   * Get the values of different columns of the value matrix.
   * 
   * The server behavior depends on the mode of the value matrix.
   * Value matrix mode 'CALCULATED':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will first calculate the physical values from raw values and
   * generation parameters, before it returns them to the requesting
   * client.
   * Value matrix mode 'STORAGE':
   * In case 'sequence_representation' of the corresponding local column
   * is one of the entries 'raw_linear', raw_polynomial',
   * 'raw_linear_external', 'raw_polynomial_external',
   * 'raw_linear_calibrated', or 'raw_linear_calibrated_external', the
   * server will return the raw values of the local column.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  columns  The requested columns.
   *
   * @param  startPoint  The starting point in the column.
   *
   * @param  count  The number of points to be retrieved. 0 mean until
   *                end of column.
   *
   * @return  The values of the different columns. The name of the return
   *          structure corresponds with the name of the column. The unit
   *          corresponds with the unit of the column. The order of the
   *          results might not match the order in the requested
   *          sequence.
   */
   NameValueSeqUnitSequence getValue(
      in ColumnSequence columns,
      in T_LONG startPoint,
      in T_LONG count)
      raises (AoException);

   /** (22022)
   * Get the current mode of the value matrix.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The mode of the value matrix
   */
   ValueMatrixMode getMode()
      raises (AoException);

}; // Interface ValueMatrix.

/**
* The ASAM ODS name-value-unitId iterator interface. This interface is
* identical with the NameValueUnitIterator, except the unit is given as
* an Id insead of a string.
*/
interface NameValueUnitIdIterator {

   /** (23001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (23002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (23003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n name-value-unit tuples from the name-value-unit
   *          tuple sequence.
   */
   NameValueSeqUnitId nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (23004)
   * Get the next element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next name-value-unitId tuple from the name-value-unitId
   *          tuple sequence.
   */
   NameValueUnitId nextOne()
      raises (AoException);

   /** (23005)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface NameValueUnitIdIterator.

/**
* The application element access.  The ApplElemAccess interface (RPC API
* GetVal, PutVal, GetInstRef, ...) is responsible to retrieve instances
* of application elements. Currently available query methods are:
* - query with attribute and value
* - query with attribute and values (not)in set
* - sorted results
* - grouped results including having condition
*/
interface ApplElemAccess {

   /** (24001)
   * Perform the Query.
   * 
   * The number of different application elements which are requested are
   * exactly defined by the definition of the query given in the field
   * anuSeq of the QueryStructure. The number of attributes for each
   * application element is also given in the definition. The number of
   * matching instances (their attributes) is not defined by the query
   * and can be a large amount. Therefore only one iterator for the
   * attribute values are defined.
   * 
   * The values of the localcolumn instances is part of the resultset
   * when the following criteria all fit:
   * 
   * - Only when the attributes id, generation_parameters, values, flags
   * are requested, as soon as any other attributes is requested the
   * values are not reported.
   * - The values of the localcolumn must all belong to exactly one
   * instances of AoMeasurement
   * - The server have a limitation of the memory, not the system memory
   * limitation, as soon as the result set will break the limitation an
   * exception will be thrown.
   * 
   * - No iterator for the rest is required.
   * 
   * In case an attribute of blob type is among the requested attributes,
   * the content of the return structure will depend on the number of
   * instances that are returned:
   * - In case attributes of only one instance are returned (either
   * because 'how_many' was set to 1 or there is only one instance
   * available at the server), the return structure contains the blob
   * itself.
   * -In case attributes of more than one instance are returned, the
   * return structure does not contain the blobs; instead it contains the
   * headers of the respective blobs.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aoq  The query definition.
   *
   * @param  how_many  Maximum number of values in each result set. Valid
   *                   arguments are: 
   *                   how_many = 0 : report all found values,
   *                   how_many > 0 : report a maximum number of values.
   *
   * @return  The result set with the requested attribute values.
   */
   ElemResultSetSequence getInstances(
      in QueryStructure aoq,
      in T_LONG how_many)
      raises (AoException);

   /** (24002)
   * Get related instances (Id). This method returns a sequence of
   * related instances. 
   * 
   * The relation name specifies the relation given in the
   * ApplStructValue. The aid of the ElemId and the relName defines the
   * unique relation and the target application element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  elem  Original instance. 
   *               
   *               At the RPC API this information was stored in the
   *               field elemId of the structure GetInstRefReq and the
   *               request AOP_GetInstRef.
   *
   * @param  relName  The relation name. 
   *                  
   *                  At the RPC API this information was stored in the
   *                  field refName of the structure GetInstRefReq   and
   *                  the request AOP_GetInstRef.
   *
   * @return  The list of the Id of the related instances.
   */
   S_LONGLONG getRelInst(
      in ElemId elem,
      in Name relName)
      raises (AoException);

   /** (24003)
   * Set the instance reference.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  elem  The instance to add the related instances.
   *               
   *               At the RPC API this information was stored in the
   *               field elemId1 of the structure SetInstRefReq  and the
   *               request AOP_SetInstRef.
   *
   * @param  relName  The name of relation. 
   *                  
   *                  At the RPC API this information was stored in the
   *                  field refName of the structure SetInstRefReq and
   *                  the request AOP_SetInstRef.
   *
   * @param  instIds  Sequence of instance id's. 
   *                  
   *                  At the RPC API this information was stored in the
   *                  field elemId2 of the structure SetInstRefReq and
   *                  the request AOP_SetInstRef. It was not possible to
   *                  set more then one relation.
   *
   * @param  type  The type of the modification, insert, update or
   *               remove. 
   *               
   *               At the RPC API this information was stored in the
   *               field on off of the structure SetInstRefReq and the
   *               request AOP_SetInstRef.
   */
   void setRelInst(
      in ElemId elem,
      in Name relName,
      in S_LONGLONG instIds,
      in SetType type)
      raises (AoException);

   /** (24004)
   * Create instance elements of an application element. 
   * The application element is specified by the AID of input structure.
   * 
   * The attribute names are specified by the name of the input
   * structure.
   * The values of one instance element are specified in the valueseq of
   * the input structure.
   * You can create several instance elements in one call by filling the
   * valueseq of the input structure.
   * The same index in the valueseq corresponds to the attributes values
   * of one instance element. This method returns a sequence of Id's, the
   * order is related to the order of instance element specified in the
   * input structure. In case of inheritance, the method supports only
   * instances of same subtype per call. The returned Id's are the Id's
   * of the related super type instances.
   * 
   * The client must supply all mandatory attributes and references
   * within one single method call; otherwise the object cannot be made
   * persistent by the server in the database without the risk of
   * violating any database constraint.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  val  The sequence of attributes and their values. 
   *              
   *              At the RPC API this information was stored in the
   *              fields elemId and nvSeq of the structure PutValReq and
   *              the request AOP_PutValReq.
   *
   * @return  List with the Id's of the new created instances.
   */
   ElemIdSequence insertInstances(
      in AIDNameValueSeqUnitIdSequence val)
      raises (AoException);

   /** (24005)
   * Update one or more attributes of one or more instance elements. It's
   * necessary that the input structure includes also the Id attribute,
   * the Id attribute will be used to select the instance elements. In
   * case of inherited application elements the super type Id has to be
   * included. The values of one instance element are specified in the
   * valueseq of the input structure. The same index in the valueseq
   * corresponds to the attributes values of one instance element. 
   * 
   * The server will update the values of the localcolumn instances when
   * the following criteria all fit:
   * 
   * - Only when the attributes id, generation_parameters, values, flags
   * are given, as soon as any other attributes is given an exception is
   * thrown.
   * - The values of the localcolumn must all belong to exactly one
   * instances of AoMeasurement
   * - The server have a limitation of the memory, not the system memory
   * limitation, as soon as the given values breaks the limitation an
   * exception will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  val  The sequence of attributes and their values. At least
   *              one of the attribute values sequence must be a sequence
   *              with the Id. 
   *              
   *              At the RPC API this information was stored in the
   *              fields elemId and nvSeq of the structure PutValReq and
   *              the request AOP_PutValReq.
   */
   void updateInstances(
      in AIDNameValueSeqUnitIdSequence val)
      raises (AoException);

   /** (24006)
   * Delete instances from an application element. In case of inherited
   * application elements the Id of the super type has to be specified.
   * 
   * This method can be used to delete several instances of the same
   * application element, the method removeInstance of the interface
   * ApplicationElement to remove one instance of an application element
   * with the children of the instance element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The application element Id.
   *
   * @param  instIds  The sequence of instance Id's. 
   *                  
   *                  At the RPC API this information was stored in the
   *                  fields elemId and nvSeq of the structure PutValReq
   *                  and the request AOP_PutValReq.
   */
   void deleteInstances(
      in T_LONGLONG aid,
      in S_LONGLONG instIds)
      raises (AoException);

   /** (24007)
   * Get the value matrix of a measurement or a submatrix. If the value
   * matrix will be built up with special submatrix link, use the
   * interface Measurement.
   * By calling this method, the value matrix mode of the returned value
   * matrix will be taken from the context variable 'VALUEMATRIX_MODE'.
   * For more information especially on different modes of the value
   * matrix, see description at the method getValueMatrixInMode() of the
   * interfaces 'Measurement' and 'SubMatrix'.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_BASETYPE
   *
   * @param  elem  The element id. The aid has to be the application
   *               element Id of the AoMeasurement or AoSubmatrix.
   *
   * @return  The value matrix
   */
   ValueMatrix getValueMatrix(
      in ElemId elem)
      raises (AoException);

   /** (24008)
   * Set the ACL information on some application element-attribute
   * defined by <aid> and <attr_name>. The <usergroup_id> defines the
   * user group the rights should be set for. <rights> defines the rights
   * to set or to clear. If the parameter <set> is set to 'set', the
   * rights in <rights> are set all others are cleared. If the parameter
   * <set> is set to 'add', the rights in <rights> are added to the
   * existing rights. If the parameter <set> is set to 'remove', the
   * rights in <rights> are removed from the existing rights. Restriction
   * for the model: only one application element of the type AoUserGroup
   * is allowed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  attrName  The name of the attribute.
   *
   * @param  usergroupId  The user group to set the rights for.
   *
   * @param  rights  The new right for the user group.
   *
   * @param  set  What to do with the new right.
   */
   void setAttributeRights(
      in T_LONGLONG aid,
      in T_STRING attrName,
      in T_LONGLONG usergroupId,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (24009)
   * Set the ACL information on some application element defined by
   * <aid>. The <usergroup_id> defines the user group the rights should
   * be set for. <rights> defines the rights to set or to clear. If the
   * parameter <set> is set to 'set', the rights in <rights> are set all
   * others are cleared. If the parameter <set> is set to 'add', the
   * rights in <rights> are added to the existing rights. If the
   * parameter <set> is set to 'remove', the rights in <rights> are
   * removed from the existing rights.  Restriction for the model: only
   * one application element of the type AoUserGroup is allowed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  usergroupId  The user group to set the rights for.
   *
   * @param  rights  The new rights for the user group. The rights
   *                 constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  set  What to do with the new right.
   */
   void setElementRights(
      in T_LONGLONG aid,
      in T_LONGLONG usergroupId,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (24010)
   * Set the ACL information on some instance defined by the application
   * element id <aid> and a sequence of instance defined by the id <iid>.
   * The <usergroup_id> defines the user group the rights should be set
   * for. <rights> defines the rights to set or to clear. If the
   * parameter <set> is set to 'set', the rights in <rights> are set all
   * others are cleared. If the parameter <set> is set to 'add', the
   * rights in <rights> are added to the existing rights. If the
   * parameter <set> is set to 'remove', the rights in <rights> are
   * removed from the existing rights.  Restriction for the model: only
   * one application element of the type AoUserGroup is allowed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  instIds  The sequence of instance Id's.
   *
   * @param  usergroupId  The user group to set the rights for.
   *
   * @param  rights  The new right for the user group.
   *
   * @param  set  What to do with the new right.
   */
   void setInstanceRights(
      in T_LONGLONG aid,
      in S_LONGLONG instIds,
      in T_LONGLONG usergroupId,
      in T_LONG rights,
      in RightsSet set)
      raises (AoException);

   /** (24011)
   * Retrieve access control list information for the given application
   * attribute <aid>/<attr_name>.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  attrName  The name of the attribute.
   *
   * @return  The access control list entries of the give application
   *          attribute.
   */
   ACLSequence getAttributeRights(
      in T_LONGLONG aid,
      in T_STRING attrName)
      raises (AoException);

   /** (24012)
   * Retrieve access control list information for the requested
   * application element <aid>.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @return  The access control list entries of the given application
   *          element.
   */
   ACLSequence getElementRights(
      in T_LONGLONG aid)
      raises (AoException);

   /** (24013)
   * Retrieve access control list information for the requested instance
   * <aid>/<iid>.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  iid  The Id of the instance.
   *
   * @return  The access control list entries of the given instance.
   */
   ACLSequence getInstanceRights(
      in T_LONGLONG aid,
      in T_LONGLONG iid)
      raises (AoException);

   /** (24014)
   * Set the access control list information for the initial rights on
   * some application element defined by <aid>. The <usergroup_id>
   * defines the user group the rights should be set for. <rights>
   * defines the rights to set or to clear. If the parameter <set> is set
   * to 'set', the rights in <rights> are set all others are cleared. If
   * the parameter <set> is set to 'add', the rights in <rights> are
   * added to the existing rights. If the parameter <set> is set to
   * 'remove', the rights in <rights> are removed from the existing
   * rights.  Restriction for the model: only one application element of
   * the type AoUserGroup is allowed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  usergroupId  The user group to set the initial rights for.
   *
   * @param  rights  The new initial rights for the user group. The
   *                 rights constants are defined in the interface
   *                 SecurityRights. The interface definition language
   *                 IDL does not allow to set the values of enumerations
   *                 thus the constant definitions had to be done in an
   *                 interface.
   *
   * @param  refAid  The Id of referencing application element for which
   *                 the initial rights will be used. If no refAid is set
   *                 the initial rights will be used for each new
   *                 instance element independent of the application
   *                 element.
   *
   * @param  set  What to do with the new initial rights.
   */
   void setElementInitialRights(
      in T_LONGLONG aid,
      in T_LONGLONG usergroupId,
      in T_LONG rights,
      in T_LONGLONG refAid,
      in RightsSet set)
      raises (AoException);

   /** (24015)
   * Set the access control list information for the initial rights on
   * some instance defined by the application element id <aid> and a
   * sequence of instance defined by the id <iid>. The <usergroup_id>
   * defines the user group the rights should be set for. <rights>
   * defines the rights to set or to clear. If the parameter <set> is set
   * to 'set', the rights in <rights> are set all others are cleared. If
   * the parameter <set> is set to 'add', the rights in <rights> are
   * added to the existing rights. If the parameter <set> is set to
   * 'remove', the rights in <rights> are removed from the existing
   * rights.  Restriction for the model: only one application element of
   * the type AoUserGroup is allowed.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  instIds  The sequence of instance Id's.
   *
   * @param  usergroupId  The user group to set the initial rights for.
   *
   * @param  rights  The new initial right for the user group.
   *
   * @param  refAid  The Id of referencing application element for which
   *                 the initial rights will be used. If no refAid is set
   *                 the initial rights will be used for each new
   *                 instance element independent of the application
   *                 element.
   *
   * @param  set  What to do with the new initial rights.
   */
   void setInstanceInitialRights(
      in T_LONGLONG aid,
      in S_LONGLONG instIds,
      in T_LONGLONG usergroupId,
      in T_LONG rights,
      in T_LONGLONG refAid,
      in RightsSet set)
      raises (AoException);

   /** (24016)
   * Set the flag <set> in svcattr, if this reference will be used (or
   * not) to retrieve the Initial Rights. If more than one reference is
   * set to true, the union (or-function) of all rights are used.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *
   * @param  aid  The application element Id.
   *
   * @param  refName  The name of the reference.
   *
   * @param  set  What to do with the given reference.
   */
   void setInitialRightReference(
      in T_LONGLONG aid,
      in T_STRING refName,
      in RightsSet set)
      raises (AoException);

   /** (24017)
   * Get all attribute names (references) which are used to retrieve the
   * Initial Rights.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The application element Id.
   *
   * @return  The names of the references which will be used for the
   *          initial rights determination.
   */
   NameSequence getInitialRightReference(
      in T_LONGLONG aid)
      raises (AoException);

   /** (24018)
   * Retrieve access control list information of the initial rights for
   * the requested application element <aid>.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @return  The access control list entries of the given application
   *          element for the initial rights.
   */
   InitialRightSequence getElementInitialRights(
      in T_LONGLONG aid)
      raises (AoException);

   /** (24019)
   * Retrieve access control list information of the initial rights for
   * the requested instance <aid>/<iid>.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aid  The Id of the application element.
   *
   * @param  iid  The Id of the instance.
   *
   * @return  The access control list entries of the given instance for
   *          the initial rights.
   */
   InitialRightSequence getInstanceInitialRights(
      in T_LONGLONG aid,
      in T_LONGLONG iid)
      raises (AoException);

   /** (24020)
   * Perform the Query. This method can be used for a more powerful query
   * compared to the method getInstances of this interface, with join
   * definitions and aggregate functions.
   * 
   * The number of different application elements which are requested are
   * exactly defined by the definition of the query given in the field
   * anuSeq of the QueryStructureExt. The number of attributes for each
   * application element is also given in the definition. The number of
   * matching instances (their attributes) is not defined by the query
   * and can be a large amount. Therefore only one iterator for the
   * attribute values are defined.
   * 
   * The return is a sequence of the structure ResultSetExt . This
   * sequence will always have the length of 1. This
   * element in the structure have two fields 
   *   - firstElems of type ElemResultSetExtSequence
   *   - restElems of type ElemResultSetExtSeqIterator
   * 
   * firstElems
   * The firstElems is a sequence of ElemResultSetExt, the length of the
   * sequence corresponds with the number of different application
   * elements requested in the anuSeq of the QueryStructrueExt. The
   * structure ElemResultSetExt has the fields aid and values. The aid is
   * the Id of the application element, the values, a sequence of the
   * structure NameValueSeqUnitId are the values of the attributes. For
   * each reported attribute an entry is given in the sequence, the name
   * of the attribute is given in the field valName. The Id of the unit
   * is given in the field unitId, this is the Id of the instance of the
   * application element derived from the base element AoUnit. The values
   * are given in the field value with the type TS_ValueSeq. Each value
   * sequence has the same length, this length is maximum how_many the
   * parameter of the method. If no values are found the length of the
   * sequence is 0. The values with the same index in the different
   * sequences of the entry in the NameValueSeqUnitIdSequence belongs to
   * the same instance element. 
   * 
   * restElems
   * The restElems is an iterator for the remaining sequence of
   * ElemResultSetExt. This iterator allows to load the next N values
   * from the ResultSet. The result of the element is the same way stored
   * as at the field firstElems, the next N is the length of the sequence
   * of the field value of the NameValueSeqUnitId. The method nextOne is
   * wrong specified and should not be used, use instead the method nextN
   * with n=1. The method getCount return the total number of found
   * element, also the number already returned in firstElems. The method
   * reset set the iterator the beginning of the ResultSet, this is the
   * beginning of the firstElems.
   * 
   * The values of the localcolumn instances is part of the resultset
   * when the following criteria all fit:
   * 
   * - Only when the attributes id, generation_parameters, values, flags
   * are requested, as soon as any other attributes is requested the
   * values are not reported.
   * - The values of the localcolumn must all belong to exactly one
   * instances of AoMeasurement
   * - The server have a limitation of the memory, not the system memory
   * limitation, as soon as the result set will break the limitation an
   * exception will be thrown.
   * - No iterator for the rest is required.
   * 
   * In case an attribute of blob type is among the requested attributes,
   * the content of the return structure will depend on the number of
   * instances that are returned:
   * - In case attributes of only one instance are returned (either
   * because 'how_many' was set to 1 or there is only one instance
   * available at the server), the return structure contains the blob
   * itself.
   * - In case attributes of more than one instance are returned, the
   * return structure does not contain the blobs; instead it contains the
   * headers of the respective blobs.
   * 
   * The value of valName of query result values shall be the aaName in
   * case AggrFunc='NONE' and shall be constructed for all other AggrFunc
   * values as string concatenation of the AggrFunc value followed by a
   * '(' character, followed by the name of attribute (aaName) followed
   * by a ')' character.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  aoq  The query definition.
   *
   * @param  how_many  Maximum number of values in each result set. Valid
   *                   arguments are: 
   *                   how_many = 0 : report all found values,
   *                   how_many > 0 : report a maximum number of values.
   *
   * @return  The result set with the requested attribute values.
   */
   ResultSetExtSequence getInstancesExt(
      in QueryStructureExt aoq,
      in T_LONG how_many)
      raises (AoException);

   /** (24021)
   * Get the value matrix of a measurement or a submatrix. If the value
   * matrix will be built up with special submatrix link, use the
   * interface Measurement.
   * The behavior of the ASAM ODS server depends on whether the
   * referenced element is a submatrix or a measurement. For more
   * information on the server behavior see description at the method
   * getValueMatrixInMode() of the interfaces 'Measurement' and
   * 'SubMatrix'.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_INVALID_BASETYPE
   *    AO_INVALID_VALUEMATRIX_STRUCTURE
   *
   * @param  elem  The element id. The aid has to be the application
   *               element Id of the AoMeasurement or AoSubmatrix.
   *
   * @param  vmMode  The requested mode of the value matrix.
   *
   * @return  The value matrix.
   */
   ValueMatrix getValueMatrixInMode(
      in ElemId elem,
      in ValueMatrixMode vmMode)
      raises (AoException);

   /** (24022)
   * Get the ODSFile interface for an instance of an application element
   * derived from AoFile.
   * 
   * This method returns an ODSFile interface.
   * 
   * One parameter controls the behavior of this method:
   * The value of the parameter 'elem' (with its components 'aid' and
   * 'iid') uniquely identifies
   * an instance within the ODS storage. If no such instance exists, or
   * if the instance is not
   * an instance of an application element derived from AoFile, the
   * exception
   * AO_INVALID_BASETYPE is thrown.
   * 
   * Note that an ODS server may be set up to support the ODS security
   * concepts and that in
   * such case access to a file is only allowed if the access rights of
   * the accessing user are
   * sufficient. If the user does not have at least READ rights for the
   * instance specified by
   * 'elem' an exception AO_ACCESS_DENIED will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_INVALID_BASETYPE
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *
   * @param  elem  The instance to which the file belongs, whose access
   *               is intended.
   *
   * @return  The ODSFile interface to access the desired file.
   */
   ODSFile getODSFile(
      in ElemId elem)
      raises (AoException);

}; // Interface ApplElemAccess.

/**
* The ASAM ODS query evaluator interface allows to perform queries in
* synchronous mode and to create Query objects for asynchronous
* execution.
*/
interface QueryEvaluator {

   /** (25000)
   * Evaluate a query in synchronous mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_QUERY_TYPE_INVALID
   *    AO_QUERY_INVALID
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  queryStr  The query string.
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameters should be passed:
   *                 
   *                 Name: "MaxDuration"; 
   *                 Type: T_LONG
   *                 Comment: Can be used to restrict the processing
   *                 time. The time is given in  milliseconds,
   *                 Default value: 0 (no restriction)
   *
   * @return  The result of the query as an instance element iterator.
   */
   InstanceElementIterator getInstances(
      in T_STRING queryStr,
      in NameValueSequence params)
      raises (AoException);

   /** (25001)
   * Evaluate a query in synchronous mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_QUERY_TYPE_INVALID
   *    AO_QUERY_INVALID
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  queryStr  The query string.
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameters should be passed:
   *                 
   *                 Name: "MaxDuration"; 
   *                 Type: T_LONG
   *                 Comment: Can be used to restrict the processing
   *                 time. The time is given in  milliseconds,
   *                 Default value: 0 (no restriction)
   *
   * @return  The result of the query as a name value unit sequence
   *          iterator. Each name value unit tuple is one cell of the
   *          table. The name value unit sequence is one row of the
   *          table.
   */
   NameValueUnitSequenceIterator getTableRows(
      in T_STRING queryStr,
      in NameValueSequence params)
      raises (AoException);

   /** (25002)
   * Evaluate a query in synchronous mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_QUERY_TYPE_INVALID
   *    AO_QUERY_INVALID
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  queryStr  The query string.
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameters should be passed:
   *                 
   *                 Name: "MaxDuration"; 
   *                 Type: T_LONG
   *                 Comment: Can be used to restrict the processing
   *                 time. The time is given in  milliseconds,
   *                 Default value: 0 (no restriction)
   *
   * @return  The result of the query as a name value sequence unit
   *          sequence. Each name value sequence unit tuple is one column
   *          of the table. The name value sequence unit sequence is  the
   *          table. The result structure can be very huge.
   */
   NameValueSeqUnitSequence getTable(
      in T_STRING queryStr,
      in NameValueSequence params)
      raises (AoException);

   /** (25003)
   * Create a query object to execute it in asynchronous mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_QUERY_TYPE_INVALID
   *    AO_QUERY_INVALID
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  queryStr  The query string
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameters should be passed:
   *                 
   *                 Name: "QueryResultType"; 
   *                 Type: ResultType.
   *                 Comment: Specifies what kind of result is expected
   *                 by the client.
   *                 Default value: INSTELEM_ITERATOR_AS_RESULT
   *                 
   *                 Name: "MaxDuration"; 
   *                 Type: T_LONG
   *                 Comment: Can be used to restrict the processing
   *                 time. The time is given in  milliseconds,
   *                 Default value: 0 (no restriction)
   *
   * @return  The query object.
   */
   Query createQuery(
      in T_STRING queryStr,
      in NameValueSequence params)
      raises (AoException);

}; // Interface QueryEvaluator.

/**
* The ASAM ODS interface Query.
*/
interface Query {

   /** (26000)
   * Get the QueryEvaluator object which is responsible for this query.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The QueryEvaluator object which is responsible for this
   *          query.
   */
   QueryEvaluator getQueryEvaluator()
      raises (AoException);

   /** (26001)
   * Do the query pre-processing (optimization, etc.)  Call can be
   * omitted by the client. In this case the functionality is executed on
   * the call of executeQuery.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_INVALID_RESULTTYPE
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameters should be passed:
   *                 
   *                 Name: "QueryResultType"; 
   *                 Type: ResultType.
   *                 Comment: Specifies what kind of result is expected
   *                 by the client, this parameter is required if the
   *                 parameters isn't given at the method createQuery of
   *                 the interface QueryEvaluator.
   *                 Default value: INSTELEM_ITERATOR_AS_RESULT
   */
   void prepareQuery(
      in NameValueSequence params)
      raises (AoException);

   /** (26002)
   * Execute query in asynchronous mode.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_INVALID_RESULTTYPE
   *
   * @param  params  Sequence of parameter names and values. The
   *                 following parameter should be passed:
   *                 
   *                 Name: "QueryResultType"; 
   *                 Type: ResultType.
   *                 Comment: Specifies what kind of result is expected
   *                 by the client, this parameter is required if the
   *                 parameters isn't given at the method prepareQuery or
   *                 the method createQuery of the interface
   *                 QueryEvaluator.
   *                 Default value: INSTELEM_ITERATOR_AS_RESULT
   *                 
   *                 Name: "Synchronous";
   *                 Type: T_BOOLEAN
   *                 Comment: In case of "true" guarantees synchronous
   *                 execution.
   *                 Default value: "false"
   */
   void executeQuery(
      in NameValueSequence params)
      raises (AoException);

   /** (26003)
   * Return query status.
   * 
   * Returns INCOMPLETE if the query is still executing.
   * 
   * Returns COMPLETE if the query finished execution or if the query
   * execution stopped because of an error or because the timeout was
   * exceeded.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The status of the query.
   */
   QueryStatus getStatus()
      raises (AoException);

   /** (26004)
   * Get the query result. This method should only be called after the
   * query has been executed. It returns an iterator on the instances
   * that were found by the query.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_QUERY_INCOMPLETE
   *    AO_QUERY_INVALID_RESULTTYPE
   *
   * @return  The result of the query as an instance element iterator.
   */
   InstanceElementIterator getInstances()
      raises (AoException);

   /** (26005)
   * Get the query result. This method should only be called after the
   * query has been executed. It returns an iterator on the name value
   * unit sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_QUERY_INCOMPLETE
   *    AO_QUERY_INVALID_RESULTTYPE
   *
   * @return  The result of the query as a name value unit sequence
   *          iterator. Each name value unit tuple is one cell of the
   *          table. The name value unit sequence is one row of the
   *          table.
   */
   NameValueUnitSequenceIterator getTableRows()
      raises (AoException);

   /** (26006)
   * Get the query result. This method should only be called after the
   * query has been executed. It returns the result as an structure.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_QUERY_PROCESSING_ERROR
   *    AO_QUERY_TIMEOUT_EXCEEDED
   *    AO_QUERY_INCOMPLETE
   *    AO_QUERY_INVALID_RESULTTYPE
   *
   * @return  The result of the query as a name value sequence unit
   *          sequence. Each name value sequence unit tuple is one column
   *          of the table. The name value sequence unit sequence is  the
   *          table. The result structure can be very huge.
   */
   NameValueSeqUnitSequence getTable()
      raises (AoException);

}; // Interface Query.

/**
* The name value unit sequence iterator. The table iterator as query
* result.
*/
interface NameValueUnitSequenceIterator {

   /** (27001)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (27002)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (27003)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n values of the name-value-unit  sequence. For
   *          each NameValuUnit the next n values are stored in the value
   *          sequence.
   */
   NameValueSeqUnitSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (27004)
   * Get the next element from the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next name-value-unit tuple sequence from the
   *          name-value-unit tuple.
   */
   NameValueSeqUnit nextOne()
      raises (AoException);

   /** (27005)
   * Reset the pointer in the element iterator to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface NameValueUnitSequenceIterator.

/**
* The ASAM ODS enumeration interface.
*/
interface EnumerationDefinition {

   /** (28000)
   * List the possible names of the enumeration. The sort order of the
   * list is the value of the item. The first item has the value zero.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  List with all possible names of the enumeration items.
   */
   NameSequence listItemNames()
      raises (AoException);

   /** (28001)
   * Get the value of an item.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @param  itemName  The name of the item.
   *
   * @return  The number of the item.
   */
   T_LONG getItem(
      in T_STRING itemName)
      raises (AoException);

   /** (28002)
   * Get the name of an item.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @param  item  The value of the item.
   *
   * @return  The name of the item.
   */
   T_STRING getItemName(
      in T_LONG item)
      raises (AoException);

   /** (28003)
   * Add a new item to the enumeration. This method modifies the
   * application model and is only allowed for the super user.
   * 
   * The name of an item must not exceed the maximum name length of the
   * underlying physical storage. Current server implementations restrict
   * it to 128 characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *    AO_DUPLICATE_NAME
   *    AO_DUPLICATE_VALUE
   *
   * @param  itemName  The name of the new item.
   */
   void addItem(
      in T_STRING itemName)
      raises (AoException);

   /** (28004)
   * Rename the item of the enumeration. This method modifies the
   * application model and is only allowed for the super user.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_NOT_FOUND
   *
   * @param  oldItemName  The existing name of the item.
   *
   * @param  newItemName  the new name of the item.
   */
   void renameItem(
      in T_STRING oldItemName,
      in T_STRING newItemName)
      raises (AoException);

   /** (28005)
   * Get the name of the enumeration.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Name of the enumeration.
   */
   T_STRING getName()
      raises (AoException);

   /** (28006)
   * Set the name of the enumeration. This method modifies the
   * application model and is only allowed for the super user.
   * 
   * The name of an enumeration definition must not exceed the maximum
   * name length of the underlying physical storage. Current server
   * implementations restrict it to 30 characters.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_TRANSACTION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *
   * @param  enumName  Name of the enumeration.
   */
   void setName(
      in T_STRING enumName)
      raises (AoException);

   /** (28007)
   * Get the index of the enumeration.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_BAD_PARAMETER
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The index of the enumeration.
   */
   T_LONG getIndex()
      raises (AoException);

}; // Interface EnumerationDefinition.

/**
* For iteration through the result elements, there is also a new iterator
* necessary called ElemResultSetExtSeqIterator. It’s functionality is
* still the same as all other iterators and needs therefore no further
* explanation.
* There is only one difference to the other iterations. The iteration is
* done on the lowest level in that case on the TS_UnionSeq.
*/
interface ElemResultSetExtSeqIterator {

   /** (29000)
   * Destroy the iterator and free the associated memory.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void destroy()
      raises (AoException);

   /** (29001)
   * Get the total number of elements accessible by the iterator.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The number of elements accessible by the iterator.
   */
   T_LONG getCount()
      raises (AoException);

   /** (29002)
   * Get the next n elements from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @param  how_many  The number of requested elements.
   *
   * @return  The next n attribute values from the element result set
   *          sequence.
   */
   ElemResultSetExtSequence nextN(
      in T_LONG how_many)
      raises (AoException);

   /** (29003)
   * Get the next  element from the sequence.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The next attribute values from the element result set
   *          sequence.
   */
   ElemResultSetExt nextOne()
      raises (AoException);

   /** (29004)
   * Reset the pointer in the element sequence to the first element.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void reset()
      raises (AoException);

}; // Interface ElemResultSetExtSeqIterator.

/**
* The interface ODSFile extends the interface InstanceElement. Thus all
* methods of the interface InstanceElement do also work here. 
* 
* ODSFile allows to create a file that is under control of the ODS server
* (a 'managed file'). ODSFile furthermore allows read, write, append or
* remove operations to a managed file.
* 
* General information of the file can be retrieved from this interface as
* well. Note, that no random access on a file is provided; only a
* sequential read and a write by appending at the end is possible.
* 
* Replacing an existing file by a new one requires to first remove the
* old one and then create the new one.
*/
interface ODSFile : InstanceElement {

   /** (30000)
   * Get the ODSWriteTransfer interface for the file, to allow appending
   * further bytes to the file.
   * 
   * This method returns the ODSWriteTransfer interface for the file
   * represented by this ODSFile object. That interface allows to write
   * sequentially to the file, beginning at the end of the currently
   * existing file.
   * Before returning the interface ODSWriteTransfer, the physical file
   * will be opened for subsequent write operations.
   * 
   * In case the current user has no UPDATE right for the instance (resp.
   * for all of its attributes in case of attribute security) from which
   * this ODSFile object was created, the exception AO_ACCESS_DENIED will
   * be thrown.
   * 
   * In case the physical file referenced by this ODSFile object cannot
   * be found, the exception AO_BAD_OPERATION will be thrown.
   * 
   * In case the physical file referenced by this ODSFile object is
   * currently opened by an ODSReadTransfer or an ODSWriteTransfer
   * object, the exception AO_FILE_LOCKED will be thrown.
   * 
   * In case the file cannot be opened for writing the exception
   * AO_SYSTEM_PROBLEM will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_FILE_LOCKED
   *    AO_ACCESS_DENIED
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *
   * @return  The ODSWriteTransfer interface to append to the file.
   */
   ODSWriteTransfer append()
      raises (AoException);

   /** (30001)
   * Check whether the file may be opened for reading.
   * 
   * This method checks whether the file represented by this ODSFile
   * object may be opened by the ODS server for reading access.
   * 
   * The method returns a boolean TRUE in case the file may be opened for
   * reading, and a boolean FALSE in case it cannot be opened for reading
   * or it is already opened for write access (i.e. an ODSWriteTransfer
   * object for this file exists).
   * 
   * In case the physical file referenced by this ODSFile object cannot
   * be found, false will be returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Information about whether the file can be opened for
   *          reading
   */
   T_BOOLEAN canRead()
      raises (AoException);

   /** (30002)
   * Check whether the file may be opened for writing.
   * 
   * This method checks whether the file represented by this ODSFile
   * object may be opened by the ODS server for writing access.
   * 
   * The method returns a boolean TRUE in case the user has appropriate
   * rights and the file can be opened for writing, and a boolean FALSE
   * in case it is already opened for write access (i.e. an
   * ODSWriteTransfer object for this file exists) or for read access
   * (i.e. one or more ODSReadTransfer objects for this file exist).
   * 
   * In case ao_location is defined and the current user has no UPDATE
   * right for the instance from which this ODSFile object was created, a
   * boolean FALSE will be returned.
   * 
   * In case ao_location is undefined and the current user has no INSERT
   * right for the instance from which this ODSFile object was created, a
   * boolean FALSE will be returned.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Information about whether the file can be opened for
   *          writing
   */
   T_BOOLEAN canWrite()
      raises (AoException);

   /** (30003)
   * Create a new file at the ODS server and get the ODSWriteTransfer
   * interface for that file, to allow storing bytes to the file.
   * 
   * This method returns the ODSWriteTransfer interface for the file
   * represented by this ODSFile object. That interface allows to write
   * sequentially to the (initially empty) file. 
   * 
   * Before returning the interface ODSWriteTransfer, the physical file
   * will be created at the ODS server and opened for subsequent write
   * operations. The file name will be decided by the ODS server and set
   * as value of the attribute derived from the base attribute
   * 'ao_location' of the instance from which this ODSFile object was
   * created.
   * 
   * In case the current user has no INSERT right for the instance from
   * which this ODSFile object was created, the exception
   * AO_ACCESS_DENIED will be thrown.
   * 
   * If the attribute derived from 'ao_location' of the instance from
   * which this ODSFile object was created already has a value, the
   * instance potentially already references a file which was not yet
   * removed, and the server will check whether that former file still
   * exists. If so the exception AO_BAD_OPERATION will be thrown and no
   * new file will be created.
   * 
   * In case the file cannot be opened for writing the exception
   * AO_SYSTEM_PROBLEM will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_ACCESS_DENIED
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *
   * @return  The ODSWriteTransfer interface to a new file.
   */
   ODSWriteTransfer create()
      raises (AoException);

   /** (30004)
   * Check whether the file physically exists at the ODS server.
   * 
   * This method checks whether the file represented by this ODSFile
   * object truly exists at the expected location (e.g. on a specific
   * drive/directory) within reach of  the ODS server.
   * 
   * The method returns a boolean TRUE in case the file exists, and a
   * boolean FALSE in case it does not exist.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  Information about whether the file exists.
   */
   T_BOOLEAN exists()
      raises (AoException);

   /** (30005)
   * Get the date of the file.
   * This method returns the date of the file represented by this ODSFile
   * object. The returned string follows the rules for ODS date and time
   * specification strings.
   * The date returned shall specify the timestamp of the latest change
   * of the file. It is the information the operating system of the ODS
   * server provides; if there is no date available from the operating
   * system with exactly this meaning, the ODS server shall return the
   * closest information available.
   * In case the physical file referenced by this ODSFile object cannot
   * be found, the exception AO_SYSTEM_PROBLEM will be thrown.
   * In case the physical file referenced by this ODSFile object is
   * currently opened by an ODSWriteTransfer object of another session,
   * the exception AO_FILE_LOCKED will be thrown.
   * In case there is no file defined by the attribute derived from
   * 'ao_location', the exception AO_BAD_OPERATION will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *    AO_FILE_LOCKED
   *
   * @return  The date of last change of the file represented by this
   *          ODSFile object.
   */
   T_DATE getDate()
      raises (AoException);

   /** (30006)
   * Get the size of the file.
   * This method returns the size of the file represented by this ODSFile
   * object. 
   * The returned value shall specify the exact file size in bytes. It is
   * the information the operating system of the ODS server provides.
   * In case the physical file referenced by this ODSFile object cannot
   * be found, the exception AO_SYSTEM_PROBLEM will be thrown.
   * In case there is no file defined by the attribute derived from
   * 'ao_location', the exception AO_BAD_OPERATION will be thrown.
   * In case the physical file referenced by this ODSFile object is
   * currently opened by an ODSWriteTransfer object of another session,
   * the exception AO_FILE_LOCKED will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_FILE_LOCKED
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *
   * @return  The size in bytes of the file represented by this ODSFile
   *          object.
   */
   T_LONGLONG getSize()
      raises (AoException);

   /** (30007)
   * Remove a file from the ODS server.
   * This method removes the file represented by this ODSFile object from
   * the ODS server if the user has appropriate rights. The attribute
   * derived from the base attribute 'ao_location' of the instance from
   * which this ODSFile object was created will become undefined and
   * ao_size will be set to 0.
   * In case the current user has no DELETE right for the instance from
   * which this ODSFile object was created, the exception
   * AO_ACCESS_DENIED will be thrown.
   * In case the file is currently opened for write access (i.e. an
   * ODSWriteTransfer object for this file exists) or for read access
   * (i.e. one or more ODSReadTransfer objects for this file exist) an
   * exception AO_FILE_LOCKED will be thrown.
   * In case the physical file referenced by this ODSFile object does not
   * exist, the method will return without any further file action; it
   * will set the attribute derived from the base attribute 'ao_location'
   * to undefined and 'ao_size' to 0; it will not throw an exception to
   * signal the non-existence of the file.
   * In case the file cannot be physically deleted from its location, the
   * exception AO_SYSTEM_PROBLEM will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_FILE_LOCKED
   *    AO_ACCESS_DENIED
   *    AO_SYSTEM_PROBLEM
   */
   void remove()
      raises (AoException);

   /** (30008)
   * Get the ODSReadTransfer interface for the file.
   * This method returns the ODSReadTransfer interface for the file
   * represented by this ODSFile object. That interface allows to read
   * sequentially from the file, either starting at the very beginning or
   * at a user-specified byte location within the file.
   * Before returning the interface ODSReadTransfer, the physical file
   * will be opened for reading.
   * In case the physical file referenced by this ODSFile object is
   * currently opened by an ODSWriteTransfer object, the exception
   * AO_FILE_LOCKED will be thrown.
   * In case there is no file defined by the attribute derived from
   * 'ao_location', the exception AO_BAD_OPERATION will be thrown.
   * In case the attribute derived from 'ao_location' is defined but the
   * physical file referenced by this ODSFile object cannot be found or
   * cannot be opened for reading, the exception AO_SYSTEM_PROBLEM will
   * be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_FILE_LOCKED
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *
   * @return  The ODSReadTransfer interface to read from the file.
   */
   ODSReadTransfer read()
      raises (AoException);

   /** (30009)
   * Put a file that is already residing within reach of the ODS server
   * under control of the ODS server.
   * This method allows to put files under control of the ODS server
   * (make them a 'managed file') without the need to stream their bytes
   * through the ODSWriteTransfer interface.
   * The parameter 'sourceUrl' specifies the location of the file that
   * shall become a managed file. This location must reference a file
   * which is accessible by the server. The server will move the file to
   * a location where managed files reside and give it a name of its own
   * choice; the file will no longer exist at its previous location. The
   * server will store file name and location in the attribute derived
   * from 'ao_location' and store the size of the file in the attribute
   * derived from 'ao_size'.
   * The string value of 'sourceUrl' must comply to the URL specification
   * given in RFC 2396 with the restriction that ASAM ODS only supports
   * absolute URLs with the access scheme "file:", otherwise the
   * exception AO_BAD_PARAMETER  will be thrown.
   * In case there is no file defined by the attribute derived from
   * 'ao_location', the exception AO_BAD_OPERATION will be thrown.
   * In case the file cannot be physically moved from its original
   * location to a server-location where managed files reside, the
   * exception AO_SYSTEM_PROBLEM will be thrown (e.g. if the file
   * specified by 'sourceUrl' does not exist, or if it cannot be
   * physically moved, etc.).
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_PARAMETER
   *    AO_BAD_OPERATION
   *    AO_SYSTEM_PROBLEM
   *
   * @param  sourceUrl  Filename URL of the file to take under control as
   *                    a managed file.
   */
   void takeUnderControl(
      in T_STRING sourceUrl)
      raises (AoException);

   /** (30010)
   * Remove a file that is currently under control of the ODS server out
   * of control of the server and move it to a specified location within
   * reach of the server.
   * This method allows to take files out of control of the ODS server
   * and place them at a specified location, without the need to stream
   * their bytes through the ODSReadTransfer interface.
   * The parameter 'targetUrl' specifies the location to which the
   * currently managed file shall be moved. This location must be
   * accessible by the server. The server will move the file from the
   * location where managed files reside to the location given by
   * 'targetUrl'; the file will no longer exist at its previous location.
   * The server will set the value of the attribute derived from
   * 'ao_location' to undefined and of the attribute derived from
   * 'ao_size' to 0.
   * The string value of 'targetUrl' must comply to the URL specification
   * given in RFC 2396 with the restriction that ASAM ODS only supports
   * absolute URLs with the access scheme "file:"; otherwise the
   * exception AO_BAD_PARAMETER  will be thrown.
   * In case the file specified by 'targetUrl' already exists the
   * exception AO_BAD_PARAMETER will be thrown and no action will be
   * performed by this method.
   * In case the file specified by 'targetUrl' cannot be physically moved
   * to the intended location, the exception AO_SYSTEM_PROBLEM will be
   * thrown and no action will be performed by this method.
   * In case the file referenced by this ODSFile object is currently
   * opened for write access (i.e. an ODSWriteTransfer object for this
   * file exists) or for read access (i.e. one or more ODSReadTransfer
   * objects for this file exist) an exception AO_FILE_LOCKED will be
   * thrown and no action will be performed by this method.
   * In case there is no file defined by the attribute derived from
   * 'ao_location', the exception AO_BAD_OPERATION will be thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_PARAMETER
   *    AO_FILE_LOCKED
   *    AO_SYSTEM_PROBLEM
   *    AO_BAD_OPERATION
   *    AO_BAD_PARAMETER
   *
   * @param  targetUrl  Filename URL of the file where to move the
   *                    managed file.
   */
   void removeFromControl(
      in T_STRING targetUrl)
      raises (AoException);

}; // Interface ODSFile.

/**
* The interface which allows a read transfer (from the ODS server to a
* client) of the content of a file that is under control of the ODS
* server.
*/
interface ODSReadTransfer {

   const T_LONG READALL = -1; // Read all bytes of the file.

   /** (31000)
   * Close this ODSReadTransfer interface.
   * 
   * This method closes the file on the ODS server's file system and
   * destroys this ODSReadTransfer object.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void close()
      raises (AoException);

   /** (31001)
   * Read a sequence of bytes from the file.
   * This method reads the file at the ODS server referenced by this
   * ODSReadTransfer and returns a sequence of bytes from that file.
   * 
   * The parameter 'maxOctets' controls the return behavior of the ODS
   * server. If the file contains more bytes than are given by
   * 'maxOctets', only 'maxOctets' bytes will be returned in the first
   * method invocation. A subsequent method invocation will return the
   * next 'maxOctets' bytes from the file, etc., until the complete file
   * contents has been returned. Further method invocations return an
   * empty sequence.
   * 
   * If 'maxOctets' is given with a equal to the constant READALL(-1),
   * there is no restriction on the number of bytes, and the complete
   * file contents will be returned with only one method invocation.
   * 
   * Note that only a sequential reading, starting at the first byte of
   * the file, is supported by this interface. If previous parts of the
   * file need to be accessed again, the current ODSReadTransfer object
   * must be closed and a new one must be instantiated.
   * 
   * In case the parameter 'maxOctets' is negative other then the
   * constant READALL the exception AO_BAD_PARAMETER is thrown.
   * 
   * In case there is any problem reading the file, the exception
   * AO_SYSTEM_PROBLEM is thrown.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_SYSTEM_PROBLEM
   *    AO_BAD_PARAMETER
   *
   * @param  maxOctets  The maximum number of bytes to be returned by one
   *                    method call.
   *
   * @return  The next (at most 'maxOctets') bytes in the file.
   */
   S_BYTE getOctetSeq(
      in T_LONG maxOctets)
      raises (AoException);

   /** (31002)
   * Skip a number of bytes while reading the file.
   * This method moves the read pointer in the file a number of bytes
   * ahead, starting at its current position; it will not return those
   * bytes. The parameter 'numOctets' specifies the number of bytes to
   * skip.
   * 
   * The method returns the true number of bytes that were skipped. This
   * may differ from 'numOctets' e.g. if the end of the file was reached.
   * If the read pointer has reached the end of the file any further
   * method invocations will return a value of 0 for 'numSkipped'.
   * 
   * This method may be invoked several times and may be arbitrarily
   * combined with getOctetSeq().
   * 
   * Note that only a sequential reading, starting at the first byte of
   * the file, is supported by this interface. If previous parts of the
   * file need to be accessed again, the current ODSReadTransfer object
   * must be closed and a new one must be instantiated.
   * 
   * If 'numOctets' is given with a value less than 0, the method will
   * throw the exception AO_BAD_PARAMETER and will not perform any file
   * access nor change the read pointer.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_BAD_PARAMETER
   *
   * @param  numOctets  The number of bytes to be skipped.
   *
   * @return  the real number of bytes skipped in the file.
   */
   T_LONGLONG skipOctets(
      in T_LONGLONG numOctets)
      raises (AoException);

   /** (31003)
   * Retrieve the current position of the read pointer in the file.
   * 
   * This method returns the current byte position of the file pointer.
   * The start of the file corresponds to a position of 0.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The current position of the read pointer in the file.
   */
   T_LONGLONG getPosition()
      raises (AoException);

}; // Interface ODSReadTransfer.

/**
* The interface which allows a write transfer (from a client to the ODS
* server) of the content of a file that is under control of the ODS
* server.
*/
interface ODSWriteTransfer {

   /** (32000)
   * Close this ODSWriteTransfer interface.
   * This method closes the file on the ODS server's file system; thereby
   * any data to be written to the file and still residing in ODS server
   * cache will be flushed to the file. 
   * The method finally destroys this ODSWriteTransfer object and also
   * the corresponding CORBA object. Access to such objects after having
   * invoked this close method will lead to a CORBA exception.
   * In case the file creation and/or write operations have been
   * performed within a transaction, this method will not yet save the
   * operations' results permanently at the physical file location but
   * keep them in intermediate storage until the transaction is
   * committed. The file will be locked for any access through
   * ODSReadTransfer or ODSWriteTransfer within any other session until
   * the end of the transaction.
   * Any subsequent read transfers or write transfers within the same
   * transaction are allowed, and will work on the latest version of the
   * file. In case the transaction is committed without a preceding close
   * operation the ODSWriteTransfer will be closed automatically by the
   * server.
   * In case the file creation and/or write operations have been
   * performed outside a transaction, this method will make all changes
   * permanent.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   */
   void close()
      raises (AoException);

   /** (32001)
   * Write a sequence of bytes to the file.
   * This method writes a sequence of bytes to the file at the ODS server
   * represented by this ODSWriteTransfer. 
   * 
   * The parameter 'buffer' contains the byte sequence that is to be
   * written to the file. The contents of 'buffer' will be appended at
   * the end of the file (which may also be the very start of the file in
   * case the file was newly created), and subsequent method invocations
   * will add their bytes at the then actual end of the file.
   * 
   * Note that only a sequential writing is supported by this interface.
   * If previous parts of the file need to be changed, the file must be
   * removed and a new one must be created.
   * 
   * In case the current location of the file runs out of memory or any
   * other operating system problem occurs the ODS server will return the
   * exception AO_SYSTEM_PROBLEM. In this case the results of the actual
   * putOctetSeq() invocation will be undone (no byte of 'buffer' is
   * added to the file) and the file may be closed without containing
   * 'buffer' at its end.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *    AO_NO_MEMORY
   *    AO_SYSTEM_PROBLEM
   *
   * @param  buffer  The buffer containing the sequence of bytes that
   *                 shall be written to the file.
   */
   void putOctectSeq(
      in S_BYTE buffer)
      raises (AoException);

   /** (32002)
   * Retrieve the current position of the write pointer in the file.
   * 
   * This method returns the current byte position of the write pointer.
   * The start of the file corresponds to a position of 0.
   *
   * @throws AoException
   * with the following possible error codes:
   *    AO_CONNECTION_LOST
   *    AO_IMPLEMENTATION_PROBLEM
   *    AO_NOT_IMPLEMENTED
   *    AO_NO_MEMORY
   *    AO_SESSION_NOT_ACTIVE
   *
   * @return  The current position of the write pointer in the file.
   */
   T_LONGLONG getPosition()
      raises (AoException);

}; // Interface ODSWriteTransfer.

}; // Module ods.

}; // Module asam.

}; // Module org.


#endif

/**
* The ASAM ODS error codes.
*
* AO_ACCESS_DENIED
* The ODS server denied the access.
*
* AO_BAD_OPERATION
* A method was called which is not possible for the current state.
*
* AO_BAD_PARAMETER
* A parameter of wrong type or value was passed to the method. The
* minorCode tells which parameter (1, 2, 3 or 4) is bad. If more than one
* parameter is bad, only the first one is reported.
*
* AO_CONNECTION_LOST
* Due to a hardware or network software problem the connection to the
* server was lost.
*
* AO_CONNECT_FAILED
* The connect to a server failed. This error may occur if the server is
* down or currently unreachable.
*
* AO_CONNECT_REFUSED
* The connection was refused by the server. This error may occur if the
* presented authentication information is either incorrect or incomplete.
* This error shall not occur if the server does not accept any more
* sessions due to overload problems. See AO_SESSION_LIMIT_REACHED for
* this case.
*
* AO_DUPLICATE_BASE_ATTRIBUTE
* Any application element may have only one base attribute of a certain
* type. This means it may have only one attribute of base attribute type
* NAME, one ID, one VERSION and so on.
*
* AO_DUPLICATE_NAME
* The implicit or explicit specified name is already in use but it is
* required to be unique.
*
* AO_DUPLICATE_VALUE
* The attribute is marked unique in the application model. Thus duplicate
* values are not allowed.
*
* AO_FILE_LOCKED
* The kind of access to a managed file that was requested cannot be
* granted, as the file is currently in use by another read or write
* transfer through the OO-API.
*
* AO_HAS_BASE_ATTRIBUTE
* Base attribute found. It is not allowed to modify the datatype, unique-
* or obligatory flag .
*
* AO_HAS_BASE_RELATION
* Base relation found. It is not allowed to modify the relationtype,
* -range or -ship of an application relation derived from a base
* relation.
*
* AO_HAS_INSTANCES
* The operation is not allowed for elements that have instances.
*
* AO_HAS_REFERENCES
* The requested operation is not permitted because the target element has
* references.
*
* AO_IMPLEMENTATION_PROBLEM
* This error is reserved for the reporting of implementation specific
* problems that are not properly handled by the standard error
* definitions. An application should not crash if this error occurs but
* there is no way to react to this error other than reporting and
* ignoring
* it. The intend of this error is not to leave implementation specific
* errors unreported.
*
* AO_INCOMPATIBLE_UNITS
* The units are incompatible. No conversion rule is known.
*
* AO_INVALID_ASAM_PATH
* The specified Asam path is invalid.
*
* AO_INVALID_ATTRIBUTE_TYPE
* The requested attribute type is invalid.
*
* AO_INVALID_BASETYPE
* The specified base type is invalid. The following basetypes are
* allowed:
*    AoAny
*    AoAttributeMap
*    AoEnvironment
*    AoFile
*    AoLocalColumn
*    AoLog
*    AoMeasurement
*    AoMeasurementQuantity
*    AoNameMap
*    AoParameter
*    AoParameterSet
*    AoPhysicalDimension
*    AoQuantity
*    AoQuantityGroup
*    AoSubmatrix
*    AoSubTest
*    AoTest
*    AoTestDevice
*    AoTestEquipment
*    AoTestEquipmentPart
*    AoTestSequence
*    AoTestSequencePart
*    AoUnit
*    AoUnitGroup
*    AoUnitUnderTest
*    AoUnitUnderTestPart
*    AoUser
*    AoUserGroup
*
* AO_INVALID_BASE_ELEMENT
* The base element is invalid in this context. If this is an element of
* type measurement, another element of this type may already exist.
*
* AO_INVALID_BUILDUP_FUNCTION
* The specified build-up function is invalid.
*
* AO_INVALID_COLUMN
* The specified column is invalid.
*
* AO_INVALID_COUNT
* The specified number of points is invalid (probably negative).
*
* AO_INVALID_DATATYPE
* The datatype is not allowed in the given context or it conflicts with
* an existing datatype definition.
* 
* This error may also occur in non-typesave language bindings. To avoid
* this error in all language bindings it is recommended to use always the
* definitions of the enumeration "DataType".
*
* AO_INVALID_ELEMENT
* The element is invalid in this context.
*
* AO_INVALID_LENGTH
* The given length is invalid. Negative length values are not allowed.
*
* AO_INVALID_ORDINALNUMBER
* The ordinal number is either already used or less than zero.
*
* AO_INVALID_RELATION
* The relation is invalid. The related elements and the base relation do
* not fit.
*
* AO_INVALID_RELATIONSHIP
* This error may occur only in non-typesave language bindings. To avoid
* this error in all language bindings it is recommended to use always the
* definitions of the enumeration "Relationship".
*
* AO_INVALID_RELATION_RANGE
* The specified relation range is invalid.
*
* AO_INVALID_RELATION_TYPE
* This error may occur only in non-typesave language bindings. To avoid
* this error in all language bindings it is recommended to use always the
* definitions of the enumeration "RelationType".
*
* AO_INVALID_SET_TYPE
* The specified set-type is invalid.
*
* AO_INVALID_SMATLINK
* The submatrix link is invalid. Either submatrix 1 or 2 is not specified
* or the ordinal number is missing when there is more than one SMatLink.
*
* AO_INVALID_SUBMATRIX
* The specified submatrix is invalid.
*
* AO_INVALID_VALUEMATRIX_STRUCTURE
* The server is unable to create the valuematrix due to the data of the
* measurement
*      - if there are no independent column
*      - if there are different independent columns
*      - if there are submatrices with more than one independent
*        column.
*      - ..
*
* AO_IS_BASE_ATTRIBUTE
* The application attribute is already of a base attribute type. It can
* not be changed. If this is required, the application attribute has to
* be removed from its application element and re-created. This error may
* occur if an application attribute derived from a base attribute
* 
*    a. shall be overwritten by another base
*       attribute type.
*    b. shall receive another datatype.
*    c. shall receive another unique-flag.
*    d. shall receive another obligatory-flag.
*
* AO_IS_BASE_RELATION
* Properties of base relations may not be changed.
*
* AO_IS_MEASUREMENT_MATRIX
* The matrix is a complex, generated matrix from a measurement not just a
* simple submatrix. It is only allowed to modify submatrices but not the
* composed measurement matrices.
*
* AO_MATH_ERROR
* A computation error occurred. This can be an overflow, an underflow or
* a division by zero.
*
* AO_MISSING_APPLICATION_ELEMENT
* A required application element is missing.
*
* AO_MISSING_ATTRIBUTE
* A required (obligatory) attribute is missing.
*
* AO_MISSING_RELATION
* A required relation is missing.
*
* AO_MISSING_VALUE
* An obligatory value is missing.
*
* AO_NOT_FOUND
* The requested element was not found. This error occurs only in remove
* or rename operations if the subject of the operation is not found. All
* get- and list-methods return an empty list if the requested item is not
* found.
*
* AO_NOT_IMPLEMENTED
* The requested method is not yet implemented. This error is not allowed
* to occur in a certified implementation. It is intended to allow partial
* operational tests. during the development process.
*
* AO_NOT_UNIQUE
* This error occurs if the instances of a property are required to be
* unique.
*
* AO_NO_MEMORY
* No more volatile memory available.
*
* AO_NO_PATH_TO_ELEMENT
* A free-floating element was detected. No navigation path leads to this
* element.
*
* AO_NO_SCALING_COLUMN
* The column is no scaling column.
*
* AO_OPEN_MODE_NOT_SUPPORTED
* The requested open mode is not supported. Valid open modes are "read"
* and "write". Anything else is rejected with this error and no session
* is created.
*
* AO_QUERY_INCOMPLETE
* The execution of the query was not yet completed.
*
* AO_QUERY_INVALID
* Some error in the query string or some inconsistency between the return
* type of the query string and the  result type specified by parameter
* "QueryResultType".
*
* AO_QUERY_INVALID_RESULTTYPE
* The requested result type of the query do no metch with the previous
* definition of the result type.
*
* AO_QUERY_PROCESSING_ERROR
* Some error occured during the execution of the query.
*
* AO_QUERY_TIMEOUT_EXCEEDED
* It was not possible to execute the query within the  time limit set by
* parameter "MaxDuration".
*
* AO_QUERY_TYPE_INVALID
* The server does not support the specified query language type.
*
* AO_SESSION_LIMIT_REACHED
* The server does not accept any new connections. This error may occur if
* the server reached the session limit for a distinct user or the total
* number of sessions allowed.
*
* AO_SESSION_NOT_ACTIVE
* The session is no longer active. This error occurs if an attempt is
* made to call a method of a closed session. This error shall not be
* confused with the error AO_CONNECTION_LOST.
*
* AO_SYSTEM_PROBLEM
* The ODS server detected a problem while accessing operating system
* ressources (e.g. the specified file does not exist, the drive is
* currently not available, ...).
*
* AO_TRANSACTION_ALREADY_ACTIVE
* There may be only one active transaction at one time. If this error
* occurs there is already an active transaction. That transaction remains
* active in case of this error.
*
* AO_TRANSACTION_NOT_ACTIVE
* Write operation have to be done always in the context of a transaction.
* This error occurs if no transaction is active during a write operation.
*
* AO_UNKNOWN_ERROR
* Use the zero as unknown error to avoid confusing error messages if no
* error code has been set.
*
* AO_UNKNOWN_UNIT
* The unit is unknown.
*/

